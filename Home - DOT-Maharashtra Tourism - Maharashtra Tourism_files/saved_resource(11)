Liferay.Loader.define("frontend-js-web@4.0.38/liferay/aop/AOP.es", ['module', 'exports', 'require'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.AOP = exports.default = void 0;

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
    }

    /**
     * Copyright (c) 2000-present Liferay, Inc. All rights reserved.
     *
     * This library is free software; you can redistribute it and/or modify it under
     * the terms of the GNU Lesser General Public License as published by the Free
     * Software Foundation; either version 2.1 of the License, or (at your option)
     * any later version.
     *
     * This library is distributed in the hope that it will be useful, but WITHOUT
     * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
     * details.
     */
    var ALTER_RETURN = 'alterReturn';
    var HALT = 'halt';
    var METAL_AOP = '__METAL_AOP__';
    var PREVENT = 'prevent';
    /**
     * AOP class
     */

    var AOP = /*#__PURE__*/function () {
      /**
       * Constructor for AOP class.
       * @param {!Object} obj The object containing the displaced function.
       * @param {!string} fnName The name of the displaced function.
       */
      function AOP(obj, fnName) {
        _classCallCheck(this, AOP);

        /**
         * Array of listeners that will invoke after the displaced function.
         * @type {!Array}
         * @protected
         */
        this.after_ = [];
        /**
         * Array of listeners that will invoke before the displaced function.
         * @type {!Array}
         * @protected
         */

        this.before_ = [];
        /**
         * The name of the displaced function.
         * @type {string}
         * @protected
         */

        this.fnName_ = fnName;
        /**
         * The displaced function.
         * @type {Function}
         * @protected
         */

        this.fn_ = obj[fnName];
        /**
         * The object hosting the method to displace.
         * @type {Object}
         * @protected
         */

        this.obj_ = obj;
      }
      /**
       * Creates handle for detaching listener from displaced function.
       * @param {!Function} fn The listener
       * @param {!boolean} before Determines when listener fires
       * @return {Object}
       */

      _createClass(AOP, [{
        key: "createHandle",
        value: function createHandle(fn, before) {
          return {
            detach: this.detach_.bind(this, fn, before)
          };
        }
        /**
         * Detaches listener from displaced function.
         * @param {!Function} fn The listener
         * @param {!boolean} before Determines when listener fires
         */

      }, {
        key: "detach_",
        value: function detach_(fn, before) {
          var listenerArray = before ? this.before_ : this.after_;
          listenerArray.splice(listenerArray.indexOf(fn), 1);
        }
        /**
         *
         * @param {any} args* Arguments are passed to the wrapping and wrapped functions.
         * @return {any} Return value of wrapped function.
         */

      }, {
        key: "exec",
        value: function exec() {
          var listenerRetVal;
          var prevented = false;
          var retVal;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          for (var i = 0; i < this.before_.length; i++) {
            listenerRetVal = this.before_[i].apply(this.obj_, args);

            if (listenerRetVal && listenerRetVal.type) {
              if (listenerRetVal.type === HALT) {
                return listenerRetVal.value;
              } else if (listenerRetVal.type === PREVENT) {
                prevented = true;
              }
            }
          }

          if (!prevented) {
            retVal = this.fn_.apply(this.obj_, args);
          }

          AOP.currentRetVal = retVal;
          AOP.originalRetVal = retVal;

          for (var _i = 0; _i < this.after_.length; _i++) {
            listenerRetVal = this.after_[_i].apply(this.obj_, args);

            if (listenerRetVal && listenerRetVal.type) {
              if (listenerRetVal.type === HALT) {
                return listenerRetVal.value;
              } else if (listenerRetVal.type === ALTER_RETURN) {
                retVal = listenerRetVal.value;
                AOP.currentRetVal = retVal;
              }
            }
          }

          return retVal;
        }
        /**
         * Registers an AOP listener.
         *
         * @param {!Function} fn the function to execute.
         * @param {boolean} before determines when the listener is invoked.
         * @return {EventHandle} Can be used to remove the listener.
         */

      }, {
        key: "register",
        value: function register(fn, before) {
          if (before) {
            this.before_.push(fn);
          } else {
            this.after_.push(fn);
          }

          return this.createHandle(fn, before);
        }
        /**
         * Executes the supplied method after the specified function.
         *
         * @param {!Function} fn the function to execute.
         * @param {!Object} obj the object hosting the method to displace.
         * @param {!string} fnName the name of the method to displace.
         * @return {EventHandle} Can be used to remove the listener.
         */

      }], [{
        key: "after",
        value: function after(fn, obj, fnName) {
          return AOP.inject(false, fn, obj, fnName);
        }
        /**
         * Return an alterReturn object when you want to change the result returned
         * from the core method to the caller.
         *
         * @param {any} value Return value passed to code that invoked the wrapped
         * function.
         * @return {Object}
         */

      }, {
        key: "alterReturn",
        value: function alterReturn(value) {
          return AOP.modify_(ALTER_RETURN, value);
        }
        /**
         * Executes the supplied method before the specified function.
         *
         * @param {!Function} fn the function to execute.
         * @param {!Object} obj the object hosting the method to displace.
         * @param {!string} fnName the name of the method to displace.
         * @return {EventHandle} Can be used to remove the listener.
         */

      }, {
        key: "before",
        value: function before(fn, obj, fnName) {
          return AOP.inject(true, fn, obj, fnName);
        }
        /**
         * Return a halt object when you want to terminate the execution
         * of all subsequent subscribers as well as the wrapped method
         * if it has not executed yet.
         *
         * @param {any} value Return value passed to code that invoked the wrapped
         * function.
         * @return {Object}
         */

      }, {
        key: "halt",
        value: function halt(value) {
          return AOP.modify_(HALT, value);
        }
        /**
         * Executes the supplied method before or after the specified function.
         *
         * @param {boolean} before determines when the listener is invoked.
         * @param {!Function} fn the function to execute.
         * @param {!Object} obj the object hosting the method to displace.
         * @param {!string} fnName the name of the method to displace.
         * @return {EventHandle} Can be used to remove the listener.
         */

      }, {
        key: "inject",
        value: function inject(before, fn, obj, fnName) {
          var aopObj = obj[METAL_AOP];

          if (!aopObj) {
            aopObj = obj[METAL_AOP] = {};
          }

          if (!aopObj[fnName]) {
            aopObj[fnName] = new AOP(obj, fnName);

            obj[fnName] = function () {
              var _aopObj$fnName;

              return (_aopObj$fnName = aopObj[fnName]).exec.apply(_aopObj$fnName, arguments);
            };
          }

          return aopObj[fnName].register(fn, before);
        }
        /**
         * Returns object which instructs `exec` method to modify the return
         * value or prevent default behavior of wrapped function.
         *
         * @param {!string} type The type of modification to be made
         * @param {any} value Return value passed to code that invoked the wrapped
         * function.
         * @return {Object}
         */

      }, {
        key: "modify_",
        value: function modify_(type, value) {
          return {
            type: type,
            value: value
          };
        }
        /**
         * Return a prevent object when you want to prevent the wrapped function
         * from executing, but want the remaining listeners to execute.
         * @return {Object}
         */

      }, {
        key: "prevent",
        value: function prevent() {
          return AOP.modify_(PREVENT);
        }
      }]);

      return AOP;
    }();

    exports.AOP = AOP;
    var _default = AOP;
    exports.default = _default;
    //# sourceMappingURL=AOP.es.js.map
  }
});
//# sourceMappingURL=AOP.es.js.map
Liferay.Loader.define("frontend-js-web@4.0.38/liferay/autosize/autosize.es", ['module', 'exports', 'require'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
    }

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }return obj;
    }

    /**
     * Copyright (c) 2000-present Liferay, Inc. All rights reserved.
     *
     * This library is free software; you can redistribute it and/or modify it under
     * the terms of the GNU Lesser General Public License as published by the Free
     * Software Foundation; either version 2.1 of the License, or (at your option)
     * any later version.
     *
     * This library is distributed in the hope that it will be useful, but WITHOUT
     * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
     * details.
     */
    var DEFAULT_APPEND_CONTENT = '&nbsp;&nbsp;';

    var AutoSize = /*#__PURE__*/function () {
      function AutoSize(inputElement) {
        var _this = this;

        _classCallCheck(this, AutoSize);

        _defineProperty(this, "handleInput", function (event) {
          requestAnimationFrame(function () {
            _this._resizeInput(event.target);
          });
        });

        this.inputElement = inputElement;
        this.computedStyle = getComputedStyle(this.inputElement);
        this.minHeight = parseInt(this.computedStyle.height.replace('px', ''), 10);
        this.template = this.createTemplate(this.computedStyle);
        document.body.appendChild(this.template);
        this.inputElement.addEventListener('input', this.handleInput);

        this._resizeInput(this.inputElement);
      }

      _createClass(AutoSize, [{
        key: "createTemplate",
        value: function createTemplate(computedStyle) {
          var template = document.createElement('pre');
          template.style.clip = 'rect(0, 0, 0, 0) !important';
          template.style.left = '0';
          template.style.overflowWrap = 'break-word';
          template.style.position = 'absolute';
          template.style.top = '0';
          template.style.transform = 'scale(0)';
          template.style.whiteSpace = 'pre-wrap';
          template.style.wordBreak = 'break-word';
          template.style.fontFamily = computedStyle.fontFamily;
          template.style.fontSize = computedStyle.fontSize;
          template.style.fontStyle = computedStyle.fontStyle;
          template.style.fontWeight = computedStyle.fontWeight;
          template.style.lineHeight = computedStyle.lineHeight;
          template.style.letterSpacing = computedStyle.letterSpacing;
          template.style.textTransform = computedStyle.textTransform;
          template.style.width = computedStyle.width;
          template.textContent = DEFAULT_APPEND_CONTENT;
          return template;
        }
      }, {
        key: "_resizeInput",
        value: function _resizeInput(inputElement) {
          if (this.template.style.width !== this.computedStyle.width) {
            this.template.style.width = this.computedStyle.width;
          }

          this.template.innerHTML = inputElement.value + DEFAULT_APPEND_CONTENT;
          inputElement.style.height = "".concat(this.template.scrollHeight < this.minHeight ? this.minHeight : this.template.scrollHeight, "px");
        }
      }]);

      return AutoSize;
    }();

    var _default = AutoSize;
    exports.default = _default;
    //# sourceMappingURL=autosize.es.js.map
  }
});
//# sourceMappingURL=autosize.es.js.map
Liferay.Loader.define("frontend-js-web@4.0.38/liferay/debounce/debounce.es", ['module', 'exports', 'require'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.cancelDebounce = cancelDebounce;
    exports.debounce = debounce;
    exports.default = void 0;

    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
    }

    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance");
    }

    function _iterableToArray(iter) {
      if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
    }

    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }return arr2;
      }
    }

    /**
     * Copyright (c) 2000-present Liferay, Inc. All rights reserved.
     *
     * This library is free software; you can redistribute it and/or modify it under
     * the terms of the GNU Lesser General Public License as published by the Free
     * Software Foundation; either version 2.1 of the License, or (at your option)
     * any later version.
     *
     * This library is distributed in the hope that it will be useful, but WITHOUT
     * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
     * details.
     */

    /**
     * Debounces function execution.
     * @param {!function()} fn
     * @param {number} delay
     * @return {!function()}
     */
    function debounce(fn, delay) {
      return function debounced() {
        var args = arguments;
        cancelDebounce(debounced);
        debounced.id = setTimeout(function () {
          fn.apply(void 0, _toConsumableArray(args));
        }, delay);
      };
    }
    /**
     * Cancels the scheduled debounced function.
     * @param {function()} debounced
     */

    function cancelDebounce(debounced) {
      clearTimeout(debounced.id);
    }

    var _default = debounce;
    exports.default = _default;
    //# sourceMappingURL=debounce.es.js.map
  }
});
//# sourceMappingURL=debounce.es.js.map
Liferay.Loader.define("frontend-js-web@4.0.38/liferay/util/form/object_to_form_data.es", ['module', 'exports', 'require', 'frontend-js-metal-web$metal'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = objectToFormData;

    var _metal = require("frontend-js-metal-web$metal");

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }return obj;
    }

    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
    }

    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }

    function _iterableToArrayLimit(arr, i) {
      if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
        return;
      }var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;_e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }return _arr;
    }

    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }

    /**
     * Returns a FormData containing serialized object.
     * @param {!Object} obj Object to convert to a FormData
     * @param {FormData=} formData FormData object to recursively append the serialized data
     * @param {string=} namespace Property namespace for nested objects or arrays
     * @return {FormData} FormData with the serialized object
     * @review
     */
    function objectToFormData() {
      var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var formData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new FormData();
      var namespace = arguments.length > 2 ? arguments[2] : undefined;
      Object.entries(obj).forEach(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            key = _ref2[0],
            value = _ref2[1];

        var formKey = namespace ? "".concat(namespace, "[").concat(key, "]") : key;

        if (Array.isArray(value)) {
          value.forEach(function (item) {
            objectToFormData(_defineProperty({}, formKey, item), formData);
          });
        } else if ((0, _metal.isObject)(value) && !(value instanceof File)) {
          objectToFormData(value, formData, formKey);
        } else {
          formData.append(formKey, value);
        }
      });
      return formData;
    }
    //# sourceMappingURL=object_to_form_data.es.js.map
  }
});
//# sourceMappingURL=object_to_form_data.es.js.map
Liferay.Loader.define("frontend-js-web@4.0.38/liferay/breakpoints", ['module', 'exports', 'require'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    /**
     * Copyright (c) 2000-present Liferay, Inc. All rights reserved.
     *
     * This library is free software; you can redistribute it and/or modify it under
     * the terms of the GNU Lesser General Public License as published by the Free
     * Software Foundation; either version 2.1 of the License, or (at your option)
     * any later version.
     *
     * This library is distributed in the hope that it will be useful, but WITHOUT
     * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
     * details.
     */
    var _default = {
      PHONE: 768,
      TABLET: 980
    };
    exports.default = _default;
    //# sourceMappingURL=breakpoints.js.map
  }
});
//# sourceMappingURL=breakpoints.js.map
'use strict';

Liferay.Loader.define("frontend-js-metal-web$metal-state@2.16.8/lib/validators", ['module', 'exports', 'require', 'frontend-js-metal-web$metal'], function (module, exports, require) {
	var define = undefined;
	var global = window;
	{
		Object.defineProperty(exports, "__esModule", {
			value: true
		});

		var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
			return typeof obj;
		} : function (obj) {
			return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
		};

		var _metal = require("frontend-js-metal-web$metal");

		var ERROR_OBJECT_OF_TYPE = 'Expected object of one type.';
		var ERROR_ONE_OF = 'Expected one of the following values:';
		var ERROR_ONE_OF_TYPE = 'Expected one of given types.';

		/**
   * Provides access to various type validators that will return an
   * instance of Error when validation fails. Note that all type validators
   * will also accept null or undefined values. To not accept these you should
   * instead make your state property required.
   */
		var validators = {
			any: function any() {
				return function () {
					return true;
				};
			},
			array: buildTypeValidator('array'),
			bool: buildTypeValidator('boolean'),
			func: buildTypeValidator('function'),
			number: buildTypeValidator('number'),
			object: buildTypeValidator('object'),
			string: buildTypeValidator('string'),

			/**
    * Creates a validator that checks that the value it receives is an array
    * of items, and that all of the items pass the given validator.
    * @param {!function()} validator Validator to check each item against.
    * @return {!function()}
    */
			arrayOf: function arrayOf(validator) {
				if (isInvalid(validators.func(validator))) {
					throwConfigError('function', validator, 'arrayOf');
				}
				return maybe(function (value, name, context) {
					var result = validators.array(value, name, context);
					if (isInvalid(result)) {
						return result;
					}
					return validateArrayItems(validator, value, name, context);
				});
			},

			/**
    * Creates a validator that checks for a value within a range.
    * @param {!Number} min The minimum value allowed.
    * @param {!Number} max The maximum value allowed.
    * @return {!function()}
    */
			inRange: function inRange(min, max) {
				var minResult = validators.number(min);
				var maxResult = validators.number(max);
				if (isInvalid(minResult)) {
					return minResult;
				}
				if (isInvalid(maxResult)) {
					return maxResult;
				}
				return maybe(function (value) {
					var valueResult = validators.number(value);
					if (isInvalid(valueResult)) {
						return valueResult;
					}
					return value >= min && value <= max;
				});
			},

			/**
    * Creates a validator that checks if a value is an instance of a given class.
    * @param {!function()} expectedClass Class to check value against.
    * @return {!function()}
    */
			instanceOf: function instanceOf(expectedClass) {
				return maybe(function (value, name, context) {
					if (value instanceof expectedClass) {
						return true;
					}

					return composeError('Expected instance of ' + expectedClass, name, context);
				});
			},

			/**
    * Creates a validator that checks that the value it receives is an object,
    * and that all values within that object pass the given validator.
    * @param {!function()} validator Validator to check each object value against.
    * @return {!function()}
    */
			objectOf: function objectOf(validator) {
				if (isInvalid(validators.func(validator))) {
					throwConfigError('function', validator, 'objectOf');
				}
				return maybe(function (value, name, context) {
					for (var key in value) {
						if (isInvalid(validator(value[key]))) {
							return composeError(ERROR_OBJECT_OF_TYPE, name, context);
						}
					}
					return true;
				});
			},

			/**
    * Creates a validator that checks if the received value matches one of the
    * given values.
    * @param {!Array} arrayOfValues Array of values to check equality against.
    * @return {!function()}
    */
			oneOf: function oneOf(arrayOfValues) {
				return maybe(function (value, name, context) {
					var result = validators.array(arrayOfValues, name, context);
					if (isInvalid(result)) {
						return result;
					}
					return arrayOfValues.indexOf(value) === -1 ? composeError(composeOneOfErrorMessage(arrayOfValues), name, context) // eslint-disable-line
					: true;
				});
			},

			/**
    * Creates a validator that checks if the received value matches one of the
    * given types.
    * @param {!Array} arrayOfTypeValidators Array of validators to check value
    *     against.
    * @return {!function()}
    */
			oneOfType: function oneOfType(arrayOfTypeValidators) {
				return maybe(function (value, name, context) {
					var result = validators.array(arrayOfTypeValidators, name, context); // eslint-disable-line
					if (isInvalid(result)) {
						return result;
					}

					for (var i = 0; i < arrayOfTypeValidators.length; i++) {
						// eslint-disable-next-line
						if (!isInvalid(arrayOfTypeValidators[i](value, name, context))) {
							return true;
						}
					}
					return composeError(ERROR_ONE_OF_TYPE, name, context);
				});
			},

			/**
    * Creates a validator that checks if the received value is an object, and
    * that its contents match the given shape.
    * @param {!Object} shape An object containing validators for each key.
    * @return {!function()}
    */
			shapeOf: function shapeOf(shape) {
				if (isInvalid(validators.object(shape))) {
					throwConfigError('object', shape, 'shapeOf');
				}
				return maybe(function (value, name, context) {
					var valueResult = validators.object(value, name, context);
					if (isInvalid(valueResult)) {
						return valueResult;
					}
					for (var key in shape) {
						if (Object.prototype.hasOwnProperty.call(shape, key)) {
							var validator = shape[key];
							var required = false;
							if (validator.config) {
								required = validator.config.required;
								validator = validator.config.validator;
							}
							if (required && !(0, _metal.isDefAndNotNull)(value[key]) || isInvalid(validator(value[key]))) {
								return validator(value[key], name + '.' + key, context);
							}
						}
					}
					return true;
				});
			}
		};

		/**
   * Creates a validator that checks against a specific primitive type.
   * @param {string} expectedType Type to check against.
   * @return {!function()} Function that runs the validator if called with
   *     arguments, or just returns it otherwise. This means that when using a
   *     type validator in `State` it may be just passed directly (like
   *     `validators.bool`), or called with no args (like `validators.bool()`).
   *     That's done to allow all validators to be used consistently, since some
   *     (like `arrayOf`) always require that you call the function before
   *     receiving the actual validator. Type validators don't need the call, but
   *     work if it's made anyway.
   */
		function buildTypeValidator(expectedType) {
			var validatorFn = maybe(validateType.bind(null, expectedType));
			return function () {
				if (arguments.length === 0) {
					return validatorFn;
				} else {
					return validatorFn.apply(undefined, arguments);
				}
			};
		}

		/**
   * Composes a warning a warning message.
   * @param {string} error Error message to display to console.
   * @param {?string} name Name of state property that is giving the error.
   * @param {Object} context The property's owner.
   * @return {!Error}
   */
		function composeError(error, name, context) {
			var compName = context ? (0, _metal.getFunctionName)(context.constructor) : null;
			var renderer = context && context.getRenderer && context.getRenderer();
			var parent = renderer && renderer.getParent && renderer.getParent();
			var parentName = parent ? (0, _metal.getFunctionName)(parent.constructor) : null;
			var location = parentName ? 'Check render method of \'' + parentName + '\'.' : '';
			return new Error('Invalid state passed to \'' + name + '\'.' + (' ' + error + ' Passed to \'' + compName + '\'. ' + location));
		}

		/**
   * Composes an error message for Config.oneOf validator.
   * @param {!Array} arrayOfValues Array of values to check equality against.
   * @return {!Error}
   */
		function composeOneOfErrorMessage(arrayOfValues) {
			return ERROR_ONE_OF + ' ' + JSON.stringify(arrayOfValues) + '.';
		}

		/**
   * Returns the type of the given value.
   * @param {*} value Any value.
   * @return {string} Type of value.
   */
		function getType(value) {
			return Array.isArray(value) ? 'array' : typeof value === 'undefined' ? 'undefined' : _typeof(value);
		}

		/**
   * Checks if the given validator result says that the value is invalid.
   * @param {boolean|!Error} result
   * @return {boolean}
   */
		function isInvalid(result) {
			return result instanceof Error;
		}

		/**
   * Wraps the given validator so that it also accepts null/undefined values.
   *   a validator that checks a value against a single type, null, or
   * undefined.
   * @param {!function()} typeValidator Validator to wrap.
   * @return {!function()} Wrapped validator.
   */
		function maybe(typeValidator) {
			return function (value, name, context) {
				return (0, _metal.isDefAndNotNull)(value) ? typeValidator(value, name, context) : true; // eslint-disable-line
			};
		}

		/**
   * Throws error if validator is invoked with incorrect type.
   * @param {string} expectedType String representing the expected type.
   * @param {*} value The value to match the type of.
   * @param {!string} name Name of the function the validator is intended for.
   */
		function throwConfigError(expectedType, value, name) {
			var type = getType(value);
			throw new Error('Expected type ' + expectedType + ', but received type ' + type + '. passed to ' + name + '.');
		}

		/**
   * Checks if all the items of the given array pass the given validator.
   * @param {!function()} validator
   * @param {*} value The array to validate items for.
   * @param {string} name The name of the array property being checked.
   * @param {!Object} context Owner of the array property being checked.
   * @return {!Error|boolean} `true` if the type matches, or an error otherwise.
   */
		function validateArrayItems(validator, value, name, context) {
			for (var i = 0; i < value.length; i++) {
				if (isInvalid(validator(value[i], name, context))) {
					var itemValidatorError = validator(value[i], name, context);
					var errorMessage = 'Validator for ' + name + '[' + i + '] says: "' + itemValidatorError + '"';
					return composeError(errorMessage, name, context);
				}
			}
			return true;
		}

		/**
   * Checks if the given value matches the expected type.
   * @param {string} expectedType String representing the expected type.
   * @param {*} value The value to match the type of.
   * @param {string} name The name of the property being checked.
   * @param {!Object} context Owner of the property being checked.
   * @return {!Error|boolean} `true` if the type matches, or an error otherwise.
   */
		function validateType(expectedType, value, name, context) {
			var type = getType(value);
			if (type !== expectedType) {
				return composeError('Expected type \'' + expectedType + '\', but received type \'' + type + '\'.', name, context);
			}
			return true;
		}

		exports.default = validators;
		//# sourceMappingURL=validators.js.map
	}
});
//# sourceMappingURL=validators.js.map
'use strict';

Liferay.Loader.define('frontend-js-metal-web$metal-state@2.16.8/lib/Config', ['module', 'exports', 'require', './validators'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _validators = require('./validators');

    var _validators2 = _interopRequireDefault(_validators);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    /**
     * Sugar api that can be used as an alternative for manually building `State`
     * configuration in the expected format. For example, instead of having
     * something like this:
     *
     * ```js
     * MyClass.STATE = {
     *   foo: {
     *     required: true,
     *     validator: validators.number,
     *     value: 13
     *   }
     * };
     * ```
     *
     * You could instead do:
     *
     * ```js
     * MyClass.STATE = {
     *   foo: Config.required().number().value(13)
     * };
     * ```
     */
    var Config = {
      /**
       * An object that contains a validator function.
       * @typedef {!Object} ConfigWithValidator
       */

      /**
       * Function that creates `State` object with an `any` validator.
       * @return {ConfigWithValidator} `State` configuration object.
       */
      any: setPrimitiveValidators('any'),

      /**
       * Function that creates `State` object with an `array` validator.
       * @return {ConfigWithValidator} `State` configuration object.
       */
      array: setPrimitiveValidators('array'),

      /**
       * Function that creates `State` object with an `arrayOf` validator.
       * @param {ConfigWithValidator} stateConfig `State` configuration object
       * @return {ConfigWithValidator} `State` configuration object.
       */
      arrayOf: setNestedValidators('arrayOf'),

      /**
       * Function that creates `State` object with a `bool` validator.
       * @return {ConfigWithValidator} `State` configuration object.
       */
      bool: setPrimitiveValidators('bool'),

      /**
       * Function that creates `State` object with a `func` validator.
       * @return {ConfigWithValidator} `State` configuration object.
       */
      func: setPrimitiveValidators('func'),

      /**
       * Creates `State` configuration object with a `rangeOf` validator.
       * @param {!Number} min The minimum value allowed.
       * @param {!Number} max The maximum value allowed.
       * @return {ConfigWithValidator} `State` configuration object.
       */
      inRange: function inRange(min, max) {
        return this.validator(_validators2.default.inRange(min, max));
      },

      /**
       * Function that creates `State` object with an `instanceOf` validator.
       * @return {ConfigWithValidator} `State` configuration object.
       */
      instanceOf: setExplicitValueValidators('instanceOf'),

      /**
       * Function that creates `State` object with a `number` validator.
       * @return {ConfigWithValidator} `State` configuration object.
       */
      number: setPrimitiveValidators('number'),

      /**
       * Function that creates `State` object with an `object` validator.
       * @return {ConfigWithValidator} `State` configuration object.
       */
      object: setPrimitiveValidators('object'),

      /**
       * Function that creates `State` object with an `objectOf` validator.
       * @param {ConfigWithValidator} stateConfig `State` configuration object
       * @return {ConfigWithValidator} `State` configuration object.
       */
      objectOf: setNestedValidators('objectOf'),

      /**
       * Function that creates `State` object with an `oneOf` validator.
       * @param {!Array} values `State` configuration object
       * @return {ConfigWithValidator} `State` configuration object.
       */
      oneOf: setExplicitValueValidators('oneOf'),

      /**
       * Creates `State` configuration object with an `oneOfType` validator.
       * @param {ConfigWithValidator[]} validatorArray Array of `State` configuration objects.
       * @return {ConfigWithValidator} `State` configuration object.
       */
      oneOfType: function oneOfType(validatorArray) {
        validatorArray = validatorArray.map(function (configObj) {
          return configObj.config.validator;
        });

        return this.validator(_validators2.default.oneOfType(validatorArray));
      },

      /**
       * Creates `State` configuration object with a `shapeOf` validator.
       * @param {!Object.<string, ConfigWithValidator>} shapeObj Values being `State` configuration objects.
       * @return {ConfigWithValidator} `State` configuration object.
       */
      shapeOf: function shapeOf(shapeObj) {
        shapeObj = destructShapeOfConfigs(shapeObj);

        return this.validator(_validators2.default.shapeOf(shapeObj));
      },

      /**
       * Function that creates `State` object with an `string` validator.
       * @return {ConfigWithValidator} `State` configuration object.
       */
      string: setPrimitiveValidators('string'),

      /**
       * Adds the `internal` flag to the `State` configuration.
       * @param {boolean} internal Flag to set "internal" to. True by default.
       * @return {!Object} `State` configuration object.
       */
      internal: function internal() {
        var internal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        return mergeConfig(this, {
          internal: internal
        });
      },

      /**
       * Adds the `required` flag to the `State` configuration.
       * @param {boolean} required Flag to set "required" to. True by default.
       * @return {!Object} `State` configuration object.
       */
      required: function required() {
        var required = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        return mergeConfig(this, {
          required: required
        });
      },

      /**
       * Adds a setter to the `State` configuration.
       * @param {!function()} setter
       * @return {!Object} `State` configuration object.
       */
      setter: function setter(_setter) {
        return mergeConfig(this, {
          setter: _setter
        });
      },

      /**
       * Adds a validator to the `State` configuration.
       * @param {!function()} validator
       * @return {!Object} `State` configuration object.
       */
      validator: function validator(_validator) {
        return mergeConfig(this, {
          validator: _validator
        });
      },

      /**
       * Adds a default value to the `State` configuration.
       * @param {*} value
       * @return {!Object} `State` configuration object.
       */
      value: function value(_value) {
        return mergeConfig(this, {
          value: _value
        });
      },

      /**
       * Adds a valueFn that will return a default value for the `State` configuration.
       * @param {!function()} valueFn
       * @return {!Object} `State` configuration object.
       */
      valueFn: function valueFn(_valueFn) {
        return mergeConfig(this, {
          valueFn: _valueFn
        });
      },

      /**
       * Adds the `writeOnce` flag to the `State` configuration.
       * @param {boolean} writeOnce Flag to set "writeOnce" to. False by default.
       * @return {!Object} `State` configuration object.
       */
      writeOnce: function writeOnce() {
        var writeOnce = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        return mergeConfig(this, {
          writeOnce: writeOnce
        });
      }
    };

    /**
     * Recursively sets validators for shapeOf.
     * @param {!Object} shape The shape of specific types.
     * @return {!Object} Shape object with validators as values.
     */
    function destructShapeOfConfigs(shape) {
      var keys = Object.keys(shape);

      var retShape = {};

      keys.forEach(function (key) {
        var value = shape[key];

        retShape[key] = value.config && value.config.validator ? value.config.validator : destructShapeOfConfigs(value);
      });

      return retShape;
    }

    /**
     * Merges the given config object into the one that has been built so far.
     * @param {!Object} context The object calling this function.
     * @param {!Object} config The object to merge to the built config.
     * @return {!Object} The final object containing the built config.
     */
    function mergeConfig(context, config) {
      var obj = context;
      var objConfig = obj.config || {};

      obj = Object.create(Config);
      obj.config = {};

      Object.assign(obj.config, objConfig, config);
      return obj;
    }

    /**
     * Calls validators with provided argument.
     * @param {string} name The name of the validator.
     * @return {function()}
     */
    function setExplicitValueValidators(name) {
      return function (arg) {
        return this.validator(_validators2.default[name](arg));
      };
    }

    /**
     * Calls validators with a single nested config.
     * @param {string} name The name of the validator.
     * @return {!function()}
     */
    function setNestedValidators(name) {
      return function (arg) {
        return this.validator(_validators2.default[name](arg.config.validator));
      };
    }

    /**
     * Adds primitive type validators to the config object.
     * @param {string} name The name of the validator.
     * @return {!function()}
     */
    function setPrimitiveValidators(name) {
      return function () {
        return this.validator(_validators2.default[name]);
      };
    }

    exports.default = Config;
    //# sourceMappingURL=Config.js.map
  }
});
//# sourceMappingURL=Config.js.map
'use strict';

Liferay.Loader.define("frontend-js-metal-web$metal-state@2.16.8/lib/State", ['module', 'exports', 'require', 'frontend-js-metal-web$metal', 'frontend-js-metal-web$metal-events'], function (module, exports, require) {
	var define = undefined;
	var global = window;
	{
		Object.defineProperty(exports, "__esModule", {
			value: true
		});

		var _createClass = function () {
			function defineProperties(target, props) {
				for (var i = 0; i < props.length; i++) {
					var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
				}
			}return function (Constructor, protoProps, staticProps) {
				if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
			};
		}();

		var _get = function get(object, property, receiver) {
			if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
				var parent = Object.getPrototypeOf(object);if (parent === null) {
					return undefined;
				} else {
					return get(parent, property, receiver);
				}
			} else if ("value" in desc) {
				return desc.value;
			} else {
				var getter = desc.get;if (getter === undefined) {
					return undefined;
				}return getter.call(receiver);
			}
		};

		var _metal = require("frontend-js-metal-web$metal");

		var _metalEvents = require("frontend-js-metal-web$metal-events");

		function _classCallCheck(instance, Constructor) {
			if (!(instance instanceof Constructor)) {
				throw new TypeError("Cannot call a class as a function");
			}
		}

		function _possibleConstructorReturn(self, call) {
			if (!self) {
				throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
			}return call && (typeof call === "object" || typeof call === "function") ? call : self;
		}

		function _inherits(subClass, superClass) {
			if (typeof superClass !== "function" && superClass !== null) {
				throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
			}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
		}

		/**
   * State adds support for having object properties that can be watched for
   * changes, as well as configured with validators, setters and other options.
   * See the `configState` method for a complete list of available configuration
   * options for each state key.
   * @extends {EventEmitter}
   */
		var State = function (_EventEmitter) {
			_inherits(State, _EventEmitter);

			/**
    * Constructor function for `State`.
    * @param {Object=} config Optional config object with initial values to
    *     set state properties to.
    * @param {Object=} obj Optional object that should hold the state
    *     properties. If none is given, they will be added directly to `this`
    *     instead.
    * @param {Object=} context Optional context to call functions (like
    *     validators and setters) on. Defaults to `this`.
    */
			function State(config, obj, context) {
				_classCallCheck(this, State);

				/**
     * Context to call functions (like validators and setters) on.
     * @type {!Object}
     * @protected
     */
				var _this = _possibleConstructorReturn(this, (State.__proto__ || Object.getPrototypeOf(State)).call(this));

				_this.context_ = context || _this;

				/**
     * Map of keys that can not be used as state keys.
     * @type {Object<string, boolean>}
     * @protected
     */
				_this.keysBlacklist_ = null;

				/**
     * Object that should hold the state properties.
     * @type {!Object}
     * @protected
     */
				_this.obj_ = obj || _this;

				_this.eventData_ = null;

				/**
     * Object with information about the batch event that is currently
     * scheduled, or null if none is.
     * @type {Object}
     * @protected
     */
				_this.scheduledBatchData_ = null;

				/**
     * Object that contains information about all this instance's state keys.
     * @type {!Object<string, !Object>}
     * @protected
     */
				_this.stateInfo_ = {};

				_this.stateConfigs_ = {};

				_this.initialValues_ = _metal.object.mixin({}, config);

				_this.setShouldUseFacade(true);
				_this.configStateFromStaticHint_();

				Object.defineProperty(_this.obj_, State.STATE_REF_KEY, {
					configurable: true,
					enumerable: false,
					value: _this
				});
				return _this;
			}

			/**
    * Logs an error if the given property is required but wasn't given.
    * @param {string} name
    * @protected
    */

			_createClass(State, [{
				key: 'assertGivenIfRequired_',
				value: function assertGivenIfRequired_(name) {
					var config = this.stateConfigs_[name];
					if (config.required) {
						var info = this.getStateInfo(name);
						var value = info.state === State.KeyStates.INITIALIZED ? this.get(name) : this.initialValues_[name];
						if (!(0, _metal.isDefAndNotNull)(value)) {
							var errorMessage = 'The property called "' + name + '" is required but didn\'t receive a value.';
							if (this.shouldThrowValidationError()) {
								throw new Error(errorMessage);
							} else {
								console.error(errorMessage);
							}
						}
					}
				}

				/**
     * Logs an error if the `validatorReturn` is instance of `Error`.
     * @param {*} validatorReturn
     * @protected
     */

			}, {
				key: 'assertValidatorReturnInstanceOfError_',
				value: function assertValidatorReturnInstanceOfError_(validatorReturn) {
					if (validatorReturn instanceof Error) {
						if (this.shouldThrowValidationError()) {
							throw validatorReturn;
						} else {
							console.error('Warning: ' + validatorReturn);
						}
					}
				}

				/**
     * Checks that the given name is a valid state key name. If it's not, an error
     * will be thrown.
     * @param {string} name The name to be validated.
     * @throws {Error}
     * @protected
     */

			}, {
				key: 'assertValidStateKeyName_',
				value: function assertValidStateKeyName_(name) {
					if (this.keysBlacklist_ && this.keysBlacklist_[name]) {
						throw new Error('It\'s not allowed to create a state key with the name "' + name + '".');
					}
				}

				/**
     * Builds the property definition object for the specified state key.
     * @param {string} name The name of the key.
     * @return {!Object}
     * @protected
     */

			}, {
				key: 'buildKeyPropertyDef_',
				value: function buildKeyPropertyDef_(name) {
					return {
						configurable: true,
						enumerable: true,
						get: function get() {
							return this[State.STATE_REF_KEY].getStateKeyValue_(name);
						},
						set: function set(val) {
							this[State.STATE_REF_KEY].setStateKeyValue_(name, val);
						}
					};
				}

				/**
     * Calls the requested function, running the appropriate code for when it's
     * passed as an actual function object or just the function's name.
     * @param {!Function|string} fn Function, or name of the function to run.
     * @param {!Array} args optional array of parameters to be passed to the
     *   function that will be called.
     * @return {*} The return value of the called function.
     * @protected
     */

			}, {
				key: 'callFunction_',
				value: function callFunction_(fn, args) {
					if ((0, _metal.isString)(fn)) {
						return this.context_[fn].apply(this.context_, args); // eslint-disable-line
					} else if ((0, _metal.isFunction)(fn)) {
						return fn.apply(this.context_, args);
					}
				}

				/**
     * Calls the state key's setter, if there is one.
     * @param {string} name The name of the key.
     * @param {*} value The value to be set.
     * @param {*} currentValue The current value.
     * @return {*} The final value to be set.
     * @protected
     */

			}, {
				key: 'callSetter_',
				value: function callSetter_(name, value, currentValue) {
					var config = this.stateConfigs_[name];
					if (config.setter) {
						value = this.callFunction_(config.setter, [value, currentValue]);
					}
					return value;
				}

				/**
     * Calls the state key's validator, if there is one. Emits console
     * warning if validator returns a string.
     * @param {string} name The name of the key.
     * @param {*} value The value to be validated.
     * @return {boolean} Flag indicating if value is valid or not.
     * @protected
     */

			}, {
				key: 'callValidator_',
				value: function callValidator_(name, value) {
					var config = this.stateConfigs_[name];
					if (config.validator) {
						var validatorReturn = this.callFunction_(config.validator, [value, name, this.context_]);
						this.assertValidatorReturnInstanceOfError_(validatorReturn);
						return validatorReturn;
					}
					return true;
				}

				/**
     * Checks if the it's allowed to write on the requested state key.
     * @param {string} name The name of the key.
     * @return {boolean}
     */

			}, {
				key: 'canSetState',
				value: function canSetState(name) {
					var info = this.getStateInfo(name);
					return !this.stateConfigs_[name].writeOnce || !info.written;
				}

				/**
     * Adds the given key(s) to the state, together with its(their) configs.
     * Config objects support the given settings:
     *     required - When set to `true`, causes errors to be printed (via
     *     `console.error`) if no value is given for the property.
     *
     *     setter - Function for normalizing state key values. It receives the new
     *     value that was set, and returns the value that should be stored.
     *
     *     validator - Function that validates state key values. When it returns
     *     false, the new value is ignored. When it returns an instance of Error,
     *     it will emit the error to the console.
     *
     *     value - The default value for the state key. Note that setting this to
     *     an object will cause all class instances to use the same reference to
     *     the object. To have each instance use a different reference for objects,
     *     use the `valueFn` option instead.
     *
     *     valueFn - A function that returns the default value for a state key.
     *
     *     writeOnce - Ignores writes to the state key after it's been first
     *     written to. That is, allows writes only when setting the value for the
     *     first time.
     * @param {!Object.<string, !Object>|string} configs An object that maps
     *     configuration options for keys to be added to the state.
     * @param {boolean|Object|*=} context The context where the added state
     *     keys will be defined (defaults to `this`), or false if they shouldn't
     *     be defined at all.
     */

			}, {
				key: 'configState',
				value: function configState(configs, context) {
					var names = Object.keys(configs);
					if (names.length === 0) {
						return;
					}

					if (context !== false) {
						var props = {};
						for (var i = 0; i < names.length; i++) {
							var name = names[i];
							this.assertValidStateKeyName_(name);
							props[name] = this.buildKeyPropertyDef_(name);
						}
						Object.defineProperties(context || this.obj_, props);
					}

					this.stateConfigs_ = configs;
					for (var _i = 0; _i < names.length; _i++) {
						var _name = names[_i];
						configs[_name] = configs[_name].config ? configs[_name].config : configs[_name];
						this.assertGivenIfRequired_(names[_i]);
						this.validateInitialValue_(names[_i]);
					}
				}

				/**
     * Adds state keys from super classes static hint `MyClass.STATE = {};`.
     * @protected
     */

			}, {
				key: 'configStateFromStaticHint_',
				value: function configStateFromStaticHint_() {
					var ctor = this.constructor;
					if (ctor !== State) {
						var defineContext = void 0;
						if (this.obj_ === this) {
							var staticKey = State.STATE_STATIC_HINT_CONFIGURED;

							ctor[staticKey] = ctor[staticKey] || {};

							defineContext = ctor[staticKey][ctor.name] ? false : ctor.prototype; // eslint-disable-line
							ctor[staticKey][ctor.name] = true;
						}
						this.configState(State.getStateStatic(ctor), defineContext);
					}
				}

				/**
     * @inheritDoc
     */

			}, {
				key: 'disposeInternal',
				value: function disposeInternal() {
					_get(State.prototype.__proto__ || Object.getPrototypeOf(State.prototype), 'disposeInternal', this).call(this);
					this.initialValues_ = null;
					this.stateInfo_ = null;
					this.stateConfigs_ = null;
					this.scheduledBatchData_ = null;
				}

				/**
     * Emits the state change batch event.
     * @protected
     */

			}, {
				key: 'emitBatchEvent_',
				value: function emitBatchEvent_() {
					if (!this.isDisposed()) {
						this.context_.emit('stateWillChange', this.scheduledBatchData_);

						var data = this.scheduledBatchData_;
						this.scheduledBatchData_ = null;
						this.context_.emit('stateChanged', data);
					}
				}

				/**
     * Returns the value of the requested state key.
     * Note: this can and should be accomplished by accessing the value as a
     * regular property. This should only be used in cases where a function is
     * actually needed.
     * @param {string} name
     * @return {*}
     */

			}, {
				key: 'get',
				value: function get(name) {
					return this.obj_[name];
				}

				/**
     * Returns an object that maps state keys to their values.
     * @param {Array<string>=} names A list of names of the keys that should
     *   be returned. If none is given, the whole state will be returned.
     * @return {Object.<string, *>}
     */

			}, {
				key: 'getState',
				value: function getState() {
					var names = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getStateKeys();

					var state = {};

					for (var i = 0; i < names.length; i++) {
						state[names[i]] = this.get(names[i]);
					}

					return state;
				}

				/**
     * Gets information about the specified state property.
     * @param {string} name
     * @return {!Object}
     */

			}, {
				key: 'getStateInfo',
				value: function getStateInfo(name) {
					if (!this.stateInfo_[name]) {
						this.stateInfo_[name] = {};
					}
					return this.stateInfo_[name];
				}

				/**
     * Gets the config object for the requested state key.
     * @param {string} name The key's name.
     * @return {Object}
     * @protected
     */

			}, {
				key: 'getStateKeyConfig',
				value: function getStateKeyConfig(name) {
					return this.stateConfigs_ ? this.stateConfigs_[name] : null;
				}

				/**
     * Returns an array with all state keys.
     * @return {!Array.<string>}
     */

			}, {
				key: 'getStateKeys',
				value: function getStateKeys() {
					return this.stateConfigs_ ? Object.keys(this.stateConfigs_) : [];
				}

				/**
     * Gets the value of the specified state key. This is passed as that key's
     * getter to the `Object.defineProperty` call inside the `addKeyToState` method.
     * @param {string} name The name of the key.
     * @return {*}
     * @protected
     */

			}, {
				key: 'getStateKeyValue_',
				value: function getStateKeyValue_(name) {
					if (!this.warnIfDisposed_(name)) {
						this.initStateKey_(name);
						return this.getStateInfo(name).value;
					}
				}

				/**
     * Merges the STATE static variable for the given constructor function.
     * @param  {!Function} ctor Constructor function.
     * @return {boolean} Returns true if merge happens, false otherwise.
     * @static
     */

			}, {
				key: 'hasBeenSet',

				/**
     * Checks if the value of the state key with the given name has already been
     * set. Note that this doesn't run the key's getter.
     * @param {string} name The name of the key.
     * @return {boolean}
     */
				value: function hasBeenSet(name) {
					var info = this.getStateInfo(name);
					return info.state === State.KeyStates.INITIALIZED || this.hasInitialValue_(name) // eslint-disable-line
					;
				}

				/**
     * Checks if an initial value was given to the specified state property.
     * @param {string} name The name of the key.
     * @return {boolean}
     * @protected
     */

			}, {
				key: 'hasInitialValue_',
				value: function hasInitialValue_(name) {
					return this.initialValues_.hasOwnProperty(name) && (0, _metal.isDef)(this.initialValues_[name]);
				}

				/**
     * Checks if the given key is present in this instance's state.
     * @param {string} key
     * @return {boolean}
     */

			}, {
				key: 'hasStateKey',
				value: function hasStateKey(key) {
					if (!this.warnIfDisposed_(key)) {
						return !!this.stateConfigs_[key];
					}
				}

				/**
     * Informs of changes to a state key's value through an event. Won't trigger
     * the event if the value hasn't changed or if it's being initialized.
     * @param {string} name The name of the key.
     * @param {*} prevVal The previous value of the key.
     * @protected
     */

			}, {
				key: 'informChange_',
				value: function informChange_(name, prevVal) {
					if (this.shouldInformChange_(name, prevVal)) {
						var data = _metal.object.mixin({
							key: name,
							newVal: this.get(name),
							prevVal: prevVal
						}, this.eventData_);
						this.context_.emit(name + 'Changed', data);
						this.context_.emit('stateKeyChanged', data);
						this.scheduleBatchEvent_(data);
					}
				}

				/**
     * Initializes the specified state key, giving it a first value.
     * @param {string} name The name of the key.
     * @protected
     */

			}, {
				key: 'initStateKey_',
				value: function initStateKey_(name) {
					var info = this.getStateInfo(name);
					if (info.state !== State.KeyStates.UNINITIALIZED) {
						return;
					}

					info.state = State.KeyStates.INITIALIZING;
					this.setInitialValue_(name);
					if (!info.written) {
						this.setDefaultValue(name);
					}
					info.state = State.KeyStates.INITIALIZED;
				}

				/**
     * Merges two values for the STATE property into a single object.
     * @param {Object} mergedVal
     * @param {Object} currVal
     * @return {!Object} The merged value.
     * @static
     */

			}, {
				key: 'removeStateKey',

				/**
     * Removes the requested state key.
     * @param {string} name The name of the key.
     */
				value: function removeStateKey(name) {
					this.stateInfo_[name] = null;
					this.stateConfigs_[name] = null;
					delete this.obj_[name];
				}

				/**
     * Schedules a state change batch event to be emitted asynchronously.
     * @param {!Object} changeData Information about a state key's update.
     * @protected
     */

			}, {
				key: 'scheduleBatchEvent_',
				value: function scheduleBatchEvent_(changeData) {
					if (!this.scheduledBatchData_) {
						_metal.async.nextTick(this.emitBatchEvent_, this);
						this.scheduledBatchData_ = _metal.object.mixin({
							changes: {}
						}, this.eventData_);
					}

					var name = changeData.key;
					var changes = this.scheduledBatchData_.changes;
					if (changes[name]) {
						changes[name].newVal = changeData.newVal;
					} else {
						changes[name] = changeData;
					}
				}

				/**
     * Sets the value of the requested state key.
     * Note: this can and should be accomplished by setting the state key as a
     * regular property. This should only be used in cases where a function is
     * actually needed.
     * @param {string} name
     * @param {*} value
     */

			}, {
				key: 'set',
				value: function set(name, value) {
					if (this.hasStateKey(name)) {
						this.obj_[name] = value;
					}
				}

				/**
     * Sets the default value of the requested state key.
     * @param {string} name The name of the key.
     */

			}, {
				key: 'setDefaultValue',
				value: function setDefaultValue(name) {
					var config = this.stateConfigs_[name];

					if (config.value !== undefined) {
						this.set(name, config.value);
					} else {
						this.set(name, this.callFunction_(config.valueFn));
					}
				}

				/**
     * Sets data to be sent with all events emitted from this instance.
     * @param {Object} data
     */

			}, {
				key: 'setEventData',
				value: function setEventData(data) {
					this.eventData_ = data;
				}

				/**
     * Sets the initial value of the requested state key.
     * @param {string} name The name of the key.
     * @protected
     */

			}, {
				key: 'setInitialValue_',
				value: function setInitialValue_(name) {
					if (this.hasInitialValue_(name)) {
						this.set(name, this.initialValues_[name]);
						this.initialValues_[name] = undefined;
					}
				}

				/**
     * Sets a map of keys that are not valid state keys.
     * @param {!Object<string, boolean>} blacklist
     */

			}, {
				key: 'setKeysBlacklist',
				value: function setKeysBlacklist(blacklist) {
					this.keysBlacklist_ = blacklist;
				}

				/**
     * Sets the value of all the specified state keys.
     * @param {!Object.<string,*>} values A map of state keys to the values they
     *   should be set to.
     * @param {function()=} callback An optional function that will be run
     *   after the next batched update is triggered.
     */

			}, {
				key: 'setState',
				value: function setState(values, callback) {
					var _this2 = this;

					Object.keys(values).forEach(function (name) {
						return _this2.set(name, values[name]);
					});
					if (callback && this.scheduledBatchData_) {
						this.context_.once('stateChanged', callback);
					}
				}

				/**
     * Sets the value of the specified state key. This is passed as that key's
     * setter to the `Object.defineProperty` call inside the `addKeyToState`
     * method.
     * @param {string} name The name of the key.
     * @param {*} value The new value of the key.
     * @protected
     */

			}, {
				key: 'setStateKeyValue_',
				value: function setStateKeyValue_(name, value) {
					if (this.warnIfDisposed_(name) || !this.canSetState(name) || !this.validateKeyValue_(name, value)) {
						return;
					}

					var prevVal = this.get(name);
					var info = this.getStateInfo(name);
					info.value = this.callSetter_(name, value, prevVal);
					this.assertGivenIfRequired_(name);
					info.written = true;
					this.informChange_(name, prevVal);
				}

				/**
     * Checks if we should inform about a state update. Updates are ignored during
     * state initialization. Otherwise, updates to primitive values are only
     * informed when the new value is different from the previous one. Updates to
     * objects (which includes functions and arrays) are always informed outside
     * initialization though, since we can't be sure if all of the internal data
     * has stayed the same.
     * @param {string} name The name of the key.
     * @param {*} prevVal The previous value of the key.
     * @return {boolean}
     * @protected
     */

			}, {
				key: 'shouldInformChange_',
				value: function shouldInformChange_(name, prevVal) {
					var info = this.getStateInfo(name);
					return info.state === State.KeyStates.INITIALIZED && ((0, _metal.isObject)(prevVal) || prevVal !== this.get(name));
				}

				/**
     * Returns a boolean that determines whether or not should throw error when
     * vaildator functions returns an `Error` instance.
     * @return {boolean} By default returns false.
     */

			}, {
				key: 'shouldThrowValidationError',
				value: function shouldThrowValidationError() {
					return false;
				}

				/**
     * Validates the initial value for the state property with the given name.
     * @param {string} name
     * @protected
     */

			}, {
				key: 'validateInitialValue_',
				value: function validateInitialValue_(name) {
					if (this.initialValues_.hasOwnProperty(name) && !this.callValidator_(name, this.initialValues_[name])) {
						delete this.initialValues_[name];
					}
				}

				/**
     * Validates the state key's value, which includes calling the validator
     * defined in the key's configuration object, if there is one.
     * @param {string} name The name of the key.
     * @param {*} value The value to be validated.
     * @return {boolean} Flag indicating if value is valid or not.
     * @protected
     */

			}, {
				key: 'validateKeyValue_',
				value: function validateKeyValue_(name, value) {
					var info = this.getStateInfo(name);
					return info.state === State.KeyStates.INITIALIZING || this.callValidator_(name, value);
				}

				/**
     * Warns if this instance has already been disposed.
     * @param {string} name Name of the property to be accessed if not disposed.
     * @return {boolean} True if disposed, or false otherwise.
     * @protected
     */

			}, {
				key: 'warnIfDisposed_',
				value: function warnIfDisposed_(name) {
					var disposed = this.isDisposed();
					if (disposed) {
						console.warn('Error. Trying to access property "' + name + '" on disposed instance');
					}
					return disposed;
				}
			}], [{
				key: 'getStateStatic',
				value: function getStateStatic(ctor) {
					return (0, _metal.getStaticProperty)(ctor, 'STATE', State.mergeState);
				}
			}, {
				key: 'mergeState',
				value: function mergeState(mergedVal, currVal) {
					return _metal.object.mixin({}, currVal, mergedVal);
				}
			}]);

			return State;
		}(_metalEvents.EventEmitter);

		/**
   * Constant used as key on State instance for storing property definition.
   * @type {!string}
   */

		State.STATE_REF_KEY = '__METAL_STATE_REF_KEY__';

		/**
   * Constant used as key on class constructors that extend from State, stores
   * which constructors have had their static STATE configured so that
   * configuration of STATE is not repeated.
   * @type {!string}
   */
		State.STATE_STATIC_HINT_CONFIGURED = '__METAL_STATE_STATIC_HINT_CONFIGURED__';

		/**
   * Constants that represent the states that a state key can be in.
   * @type {!Object}
   */
		State.KeyStates = {
			UNINITIALIZED: undefined,
			INITIALIZING: 1,
			INITIALIZED: 2
		};

		exports.default = State;
		//# sourceMappingURL=State.js.map
	}
});
//# sourceMappingURL=State.js.map
'use strict';

Liferay.Loader.define('frontend-js-metal-web$metal-state@2.16.8/lib/all/state', ['module', 'exports', 'require', '../validators', '../Config', '../State'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.State = exports.Config = exports.validators = undefined;

    var _validators = require('../validators');

    var _validators2 = _interopRequireDefault(_validators);

    var _Config = require('../Config');

    var _Config2 = _interopRequireDefault(_Config);

    var _State = require('../State');

    var _State2 = _interopRequireDefault(_State);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = _State2.default;
    exports.validators = _validators2.default;
    exports.Config = _Config2.default;
    exports.State = _State2.default;
    //# sourceMappingURL=state.js.map
  }
});
//# sourceMappingURL=state.js.map
Liferay.Loader.define("frontend-js-web@4.0.38/liferay/CompatibilityEventProxy.es", ['module', 'exports', 'require', 'frontend-js-metal-web$metal', 'frontend-js-metal-web$metal-state'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _metal = require("frontend-js-metal-web$metal");

    var _metalState = _interopRequireDefault(require("frontend-js-metal-web$metal-state"));

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof(obj) {
          return typeof obj;
        };
      } else {
        _typeof = function _typeof(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }return _typeof(obj);
    }

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
    }

    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }return _assertThisInitialized(self);
    }

    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }return self;
    }

    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };return _getPrototypeOf(o);
    }

    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);
    }

    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;return o;
      };return _setPrototypeOf(o, p);
    }

    /**
     * Adds compatibility for YUI events, re-emitting events according to YUI naming
     * and adding the capability of adding targets to bubble events to them.
     */
    var CompatibilityEventProxy = /*#__PURE__*/function (_State) {
      _inherits(CompatibilityEventProxy, _State);

      /**
       * @inheritDoc
       */
      function CompatibilityEventProxy(config, element) {
        var _this;

        _classCallCheck(this, CompatibilityEventProxy);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(CompatibilityEventProxy).call(this, config, element));
        _this.eventTargets_ = [];
        _this.host = config.host;
        _this.namespace = config.namespace;

        _this.startCompatibility_();

        return _this;
      }
      /**
       * Registers another event target as a bubble target.
       *
       * @param  {!Object} target The YUI component that receives the emitted
       *         events.
       * @private
       */

      _createClass(CompatibilityEventProxy, [{
        key: "addTarget",
        value: function addTarget(target) {
          this.eventTargets_.push(target);
        }
        /**
         * Checks if the event is an attribute modification event and adapts the
         * event name accordingly.
         *
         * @param  {!String} eventName The event name.
         * @private
         * @return {String} The adapted event name.
         */

      }, {
        key: "checkAttributeEvent_",
        value: function checkAttributeEvent_(eventName) {
          return eventName.replace(this.adaptedEvents.match, this.adaptedEvents.replace);
        }
        /**
         * Emits the event adapted to YUI.
         *
         * @param  {!String} eventName The event name.
         * @param  {!Event} event The event.
         * @private
         */

      }, {
        key: "emitCompatibleEvents_",
        value: function emitCompatibleEvents_(eventName, event) {
          var _this2 = this;

          this.eventTargets_.forEach(function (target) {
            if (target.fire) {
              var prefixedEventName = _this2.namespace ? _this2.namespace + ':' + eventName : eventName;
              var yuiEvent = target._yuievt.events[prefixedEventName];

              if (_metal.core.isObject(event)) {
                try {
                  event.target = _this2.host;
                } catch (e) {// Do nothing
                }
              }

              var emitFacadeReference;

              if (!_this2.emitFacade && yuiEvent) {
                emitFacadeReference = yuiEvent.emitFacade;
                yuiEvent.emitFacade = false;
              }

              target.fire(prefixedEventName, event);

              if (!_this2.emitFacade && yuiEvent) {
                yuiEvent.emitFacade = emitFacadeReference;
              }
            }
          });
        }
        /**
         * Emits YUI-based events to maintain backwards compatibility.
         *
         * @private
         */

      }, {
        key: "startCompatibility_",
        value: function startCompatibility_() {
          var _this3 = this;

          this.host.on('*', function (event, eventFacade) {
            if (!eventFacade) {
              eventFacade = event;
            }

            var compatibleEvent = _this3.checkAttributeEvent_(eventFacade.type);

            if (compatibleEvent !== eventFacade.type) {
              eventFacade.type = compatibleEvent;

              _this3.host.emit(compatibleEvent, event, eventFacade);
            } else if (_this3.eventTargets_.length > 0) {
              _this3.emitCompatibleEvents_(compatibleEvent, event);
            }
          });
        }
      }]);

      return CompatibilityEventProxy;
    }(_metalState.default);
    /**
     * State definition.
     *
     * @ignore
     * @static
     * @type {!Object}
     */

    CompatibilityEventProxy.STATE = {
      /**
       * Replaces event names with adapted YUI names.
       *
       * @instance
       * @memberof CompatibilityEventProxy
       * @type {Object}
       */
      adaptedEvents: {
        value: {
          match: /(.*)(Changed)$/,
          replace: '$1Change'
        }
      },

      /**
       * Whether the event facade should be emitted to the target.
       *
       * @default false
       * @instance
       * @memberof CompatibilityEventProxy
       * @type {String}
       */
      emitFacade: {
        value: false
      }
    };
    var _default = CompatibilityEventProxy;
    exports.default = _default;
    //# sourceMappingURL=CompatibilityEventProxy.es.js.map
  }
});
//# sourceMappingURL=CompatibilityEventProxy.es.js.map
'use strict';

Liferay.Loader.define('frontend-js-metal-web$metal-component@2.16.8/lib/events/events', ['module', 'exports', 'require', 'frontend-js-metal-web$metal'], function (module, exports, require) {
	var define = undefined;
	var global = window;
	{
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.addListenersFromObj = addListenersFromObj;
		exports.getComponentFn = getComponentFn;

		var _metal = require('frontend-js-metal-web$metal');

		/**
   * Adds the listeners specified in the given object.
   * @param {!Component} component
   * @param {Object} events
   * @return {!Array<!EventHandle>} Handles from all subscribed events.
   */
		function addListenersFromObj(component, events) {
			var eventNames = Object.keys(events || {});
			var handles = [];
			for (var i = 0; i < eventNames.length; i++) {
				var info = extractListenerInfo_(component, events[eventNames[i]]);
				if (info.fn) {
					var handle = void 0;
					if (info.selector) {
						handle = component.delegate(eventNames[i], info.selector, info.fn); // eslint-disable-line
					} else {
						handle = component.on(eventNames[i], info.fn);
					}
					handles.push(handle);
				}
			}
			return handles;
		}

		/**
   * Extracts listener info from the given value.
   * @param {!Component} component
   * @param {function()|string|{selector:string,fn:function()}|string} value
   * @return {!{selector:string,fn:function()}}
   * @protected
   */
		function extractListenerInfo_(component, value) {
			var info = {
				fn: value
			};
			if ((0, _metal.isObject)(value) && !(0, _metal.isFunction)(value)) {
				info.selector = value.selector;
				info.fn = value.fn;
			}
			if ((0, _metal.isString)(info.fn)) {
				info.fn = getComponentFn(component, info.fn);
			}
			return info;
		}

		/**
   * Gets the listener function from its name. Throws an error if none exist.
   * @param {!Component} component
   * @param {string} fnName
   * @return {function()}
   */
		function getComponentFn(component, fnName) {
			if ((0, _metal.isFunction)(component[fnName])) {
				return component[fnName].bind(component);
			} else {
				console.error('No function named ' + fnName + ' was found in the component\n\t\t\t"' + (0, _metal.getFunctionName)(component.constructor) + '". Make sure that you specify\n\t\t\tvalid function names when adding inline listeners');
			}
		}
		//# sourceMappingURL=events.js.map
	}
});
//# sourceMappingURL=events.js.map
'use strict';

Liferay.Loader.define('frontend-js-metal-web$metal-component@2.16.8/lib/sync/sync', ['module', 'exports', 'require', 'frontend-js-metal-web$metal'], function (module, exports, require) {
	var define = undefined;
	var global = window;
	{
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.syncState = syncState;

		var _metal = require('frontend-js-metal-web$metal');

		var SYNC_FNS_KEY = '__METAL_SYNC_FNS__';

		/**
   * Gets the `sync` methods for this component's state. Caches the results in
   * the component's constructor whenever possible, so that this doesn't need to
   * be calculated again. It's not possible to cache the results when at least
   * one sync method is defined in the instance itself instead of in its
   * prototype, as it may be bound to the instance (not reusable by others).
   * @param {!Component} component
   * @return {!Object}
   * @private
   */
		function getSyncFns_(component) {
			var ctor = component.constructor;
			if (ctor.hasOwnProperty(SYNC_FNS_KEY)) {
				return ctor[SYNC_FNS_KEY];
			}

			var fns = {};
			var keys = component.getDataManager().getSyncKeys(component);
			var canCache = true;
			for (var i = 0; i < keys.length; i++) {
				var name = 'sync' + keys[i].charAt(0).toUpperCase() + keys[i].slice(1);
				var fn = component[name];
				if (fn) {
					fns[keys[i]] = fn;
					canCache = canCache && component.constructor.prototype[name];
				}
			}

			if (canCache) {
				ctor[SYNC_FNS_KEY] = fns;
			}
			return fns;
		}

		/**
   * Calls "sync" functions for the given component's state.
   * @param {!Component} component
   * @param {Object=} changes When given, only the properties inside it will
   *     be synced. Otherwise all state properties will be synced.
   */
		function syncState(component, changes) {
			var syncFns = getSyncFns_(component);
			var keys = Object.keys(changes || syncFns);
			for (var i = 0; i < keys.length; i++) {
				var fn = syncFns[keys[i]];
				if ((0, _metal.isFunction)(fn)) {
					var change = changes && changes[keys[i]];
					var manager = component.getDataManager();
					fn.call(component, change ? change.newVal : manager.get(component, keys[i]), change ? change.prevVal : undefined);
				}
			}
		}
		//# sourceMappingURL=sync.js.map
	}
});
//# sourceMappingURL=sync.js.map
'use strict';

Liferay.Loader.define("frontend-js-metal-web$metal-component@2.16.8/lib/ComponentDataManager", ['module', 'exports', 'require', 'frontend-js-metal-web$metal', 'frontend-js-metal-web$metal-state'], function (module, exports, require) {
	var define = undefined;
	var global = window;
	{
		Object.defineProperty(exports, "__esModule", {
			value: true
		});

		var _createClass = function () {
			function defineProperties(target, props) {
				for (var i = 0; i < props.length; i++) {
					var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
				}
			}return function (Constructor, protoProps, staticProps) {
				if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
			};
		}();

		var _metal = require("frontend-js-metal-web$metal");

		var _metalState = require("frontend-js-metal-web$metal-state");

		var _metalState2 = _interopRequireDefault(_metalState);

		function _interopRequireDefault(obj) {
			return obj && obj.__esModule ? obj : { default: obj };
		}

		function _classCallCheck(instance, Constructor) {
			if (!(instance instanceof Constructor)) {
				throw new TypeError("Cannot call a class as a function");
			}
		}

		var BLACKLIST = {
			components: true,
			context: true,
			element: true,
			refs: true,
			state: true,
			stateKey: true,
			wasRendered: true
		};
		var DATA_MANAGER_DATA = '__DATA_MANAGER_DATA__';

		/**
   * Class to handle Component Data
   */

		var ComponentDataManager = function () {
			function ComponentDataManager() {
				_classCallCheck(this, ComponentDataManager);
			}

			_createClass(ComponentDataManager, [{
				key: 'createState_',

				/**
     * Creates the `State` instance that will handle the main component data.
     * @param {!Component} component
     * @param {!Object} data
     * @protected
     */
				value: function createState_(component, data) {
					var state = new _metalState2.default(component.getInitialConfig(), component, component); // eslint-disable-line
					state.setKeysBlacklist(BLACKLIST);
					state.configState(_metal.object.mixin({}, data, _metalState2.default.getStateStatic(component.constructor)));
					this.getManagerData(component).state_ = state;
				}

				/**
     * Disposes of any data being used by the manager in this component.
     * @param {!Component} component
     */

			}, {
				key: 'dispose',
				value: function dispose(component) {
					var data = this.getManagerData(component);
					if (data.state_) {
						data.state_.dispose();
					}
					component[DATA_MANAGER_DATA] = null;
				}

				/**
     * Gets the data with the given name.
     * @param {!Component} component
     * @param {string} name
     * @return {*}
     */

			}, {
				key: 'get',
				value: function get(component, name) {
					return this.getManagerData(component).state_.get(name);
				}

				/**
     * Gets the manager data for the given component.
     * @param {!Component} component
     * @return {Object}
     */

			}, {
				key: 'getManagerData',
				value: function getManagerData(component) {
					return component[DATA_MANAGER_DATA];
				}

				/**
     * Gets the keys for state data that can be synced via `sync` functions.
     * @param {!Component} component
     * @return {!Array<string>}
     */

			}, {
				key: 'getSyncKeys',
				value: function getSyncKeys(component) {
					return this.getManagerData(component).state_.getStateKeys();
				}

				/**
     * Gets the keys for state data.
     * @param {!Component} component
     * @return {!Array<string>}
     */

			}, {
				key: 'getStateKeys',
				value: function getStateKeys(component) {
					return this.getManagerData(component).state_.getStateKeys();
				}

				/**
     * Gets the whole state data.
     * @param {!Component} component
     * @return {!Object}
     */

			}, {
				key: 'getState',
				value: function getState(component) {
					return this.getManagerData(component).state_.getState();
				}

				/**
     * Gets the `State` instance being used.
     * @param {!Component} component
     * @return {!Object}
     */

			}, {
				key: 'getStateInstance',
				value: function getStateInstance(component) {
					return this.getManagerData(component).state_;
				}

				/**
     * Updates all non internal data with the given values (or to the default
     * value if none is given).
     * @param {!Component} component
     * @param {!Object} data
     * @param {State=} state
     */

			}, {
				key: 'replaceNonInternal',
				value: function replaceNonInternal(component, data) {
					var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.getManagerData(component).state_;

					var keys = state.getStateKeys();
					for (var i = 0; i < keys.length; i++) {
						var key = keys[i];
						if (!state.getStateKeyConfig(key).internal) {
							if (data.hasOwnProperty(key) && (0, _metal.isDef)(data[key])) {
								state.set(key, data[key]);
							} else {
								state.setDefaultValue(key);
							}
						}
					}
				}

				/**
     * Sets the value of all the specified state keys.
     * @param {!Component} component
     * @param {!Object.<string,*>} state A map of state keys to the values they
     *   should be set to.
     * @param {function()=} callback An optional function that will be run
     *   after the next batched update is triggered.
     */

			}, {
				key: 'setState',
				value: function setState(component, state, callback) {
					this.getManagerData(component).state_.setState(state, callback);
				}

				/**
     * Sets up the specified component's data.
     * @param {!Component} component
     * @param {!Object} data
     */

			}, {
				key: 'setUp',
				value: function setUp(component, data) {
					component[DATA_MANAGER_DATA] = {};
					this.createState_(component, data);
				}
			}]);

			return ComponentDataManager;
		}();

		exports.default = new ComponentDataManager();
		//# sourceMappingURL=ComponentDataManager.js.map
	}
});
//# sourceMappingURL=ComponentDataManager.js.map
'use strict';

/**
 * Base class that component renderers should extend from. It defines the
 * required methods all renderers should have.
 */

Liferay.Loader.define("frontend-js-metal-web$metal-component@2.16.8/lib/ComponentRenderer", ['module', 'exports', 'require'], function (module, exports, require) {
	var define = undefined;
	var global = window;
	{
		Object.defineProperty(exports, "__esModule", {
			value: true
		});

		var _createClass = function () {
			function defineProperties(target, props) {
				for (var i = 0; i < props.length; i++) {
					var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
				}
			}return function (Constructor, protoProps, staticProps) {
				if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
			};
		}();

		function _classCallCheck(instance, Constructor) {
			if (!(instance instanceof Constructor)) {
				throw new TypeError("Cannot call a class as a function");
			}
		}

		var ComponentRenderer = function () {
			function ComponentRenderer() {
				_classCallCheck(this, ComponentRenderer);
			}

			_createClass(ComponentRenderer, [{
				key: 'dispose',

				/**
     * Disposes of any data specific to the given component.
     * @param {!Component} component
     */
				value: function dispose() {}

				/**
     * Returns extra configuration for data that should be added to the manager.
     * Sub classes can override to return `State` config for properties that
     * should be added to the component.
     * @param {!Component} component
     */

			}, {
				key: 'getExtraDataConfig',
				value: function getExtraDataConfig() {}

				/**
     * Renders the whole content (including its main element) and informs the
     * component about it. Should be overridden by sub classes.
     * @param {!Component} component
     */

			}, {
				key: 'render',
				value: function render(component) {
					if (!component.element) {
						component.element = document.createElement('div');
					}
					component.informRendered();
				}

				/**
     * Sets up this component to be used by this renderer. Sub classes should
     * override as needed for more behavior.
     * @param {!Component} component
     */

			}, {
				key: 'setUp',
				value: function setUp() {}

				/**
     * Updates the component's element html. This is automatically called when
     * the value of at least one of the component's state keys has changed.
     * Should be implemented by sub classes. Sub classes have to remember to call
     * "informRendered" on the component when any update rendering is done.
     * @param {!Component} component
     * @param {Object.<string, Object>} changes Object containing the names
     *     of all changed state keys, each mapped to an object with its new
     *     (newVal) and previous (prevVal) values.
     */

			}, {
				key: 'update',
				value: function update() {}
			}]);

			return ComponentRenderer;
		}();

		exports.default = new ComponentRenderer();
		//# sourceMappingURL=ComponentRenderer.js.map
	}
});
//# sourceMappingURL=ComponentRenderer.js.map
'use strict';

Liferay.Loader.define("frontend-js-metal-web$metal-component@2.16.8/lib/Component", ['module', 'exports', 'require', './events/events', 'frontend-js-metal-web$metal', './sync/sync', 'frontend-js-metal-web$metal-dom', './ComponentDataManager', './ComponentRenderer', 'frontend-js-metal-web$metal-events'], function (module, exports, require) {
	var define = undefined;
	var global = window;
	{
		Object.defineProperty(exports, "__esModule", {
			value: true
		});

		var _createClass = function () {
			function defineProperties(target, props) {
				for (var i = 0; i < props.length; i++) {
					var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
				}
			}return function (Constructor, protoProps, staticProps) {
				if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
			};
		}();

		var _get = function get(object, property, receiver) {
			if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
				var parent = Object.getPrototypeOf(object);if (parent === null) {
					return undefined;
				} else {
					return get(parent, property, receiver);
				}
			} else if ("value" in desc) {
				return desc.value;
			} else {
				var getter = desc.get;if (getter === undefined) {
					return undefined;
				}return getter.call(receiver);
			}
		};

		var _events = require('./events/events');

		var _metal = require("frontend-js-metal-web$metal");

		var _sync = require('./sync/sync');

		var _metalDom = require("frontend-js-metal-web$metal-dom");

		var _ComponentDataManager = require('./ComponentDataManager');

		var _ComponentDataManager2 = _interopRequireDefault(_ComponentDataManager);

		var _ComponentRenderer = require('./ComponentRenderer');

		var _ComponentRenderer2 = _interopRequireDefault(_ComponentRenderer);

		var _metalEvents = require("frontend-js-metal-web$metal-events");

		function _interopRequireDefault(obj) {
			return obj && obj.__esModule ? obj : { default: obj };
		}

		function _defineProperty(obj, key, value) {
			if (key in obj) {
				Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
			} else {
				obj[key] = value;
			}return obj;
		}

		function _toConsumableArray(arr) {
			if (Array.isArray(arr)) {
				for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
					arr2[i] = arr[i];
				}return arr2;
			} else {
				return Array.from(arr);
			}
		}

		function _classCallCheck(instance, Constructor) {
			if (!(instance instanceof Constructor)) {
				throw new TypeError("Cannot call a class as a function");
			}
		}

		function _possibleConstructorReturn(self, call) {
			if (!self) {
				throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
			}return call && (typeof call === "object" || typeof call === "function") ? call : self;
		}

		function _inherits(subClass, superClass) {
			if (typeof superClass !== "function" && superClass !== null) {
				throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
			}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
		}

		/**
   * Component collects common behaviors to be followed by UI components, such
   * as Lifecycle, CSS classes management, events encapsulation and support for
   * different types of rendering.
   * Rendering logic can be done by either:
   *     - Listening to the `render` event inside the `created` lifecycle function
   *       and adding the rendering logic to the listener.
   *     - Using an existing implementation of `ComponentRenderer` like `Soy`,
   *       and following its patterns.
   *     - Building your own implementation of a `ComponentRenderer`.
   * Specifying the renderer that will be used can be done by setting the RENDERER
   * static variable to the renderer's constructor function.
   *
   * Example:
   *
   * <code>
   * class CustomComponent extends Component {
   *   created() {
   *   }
   *
   *   rendered() {
   *   }
   *
   *   willAttach() {
   *   }
   *
   *   attached() {
   *   }
   *
   *   willReceiveState() {
   *   }
   *
   *   // willReceiveProps is only available in JSX components
   *   willReceiveProps() {
   *   }
   *
   *   shouldUpdate() {
   *   }
   *
   *   willUpdate() {
   *   }
   *
   *   willDetach() {
   *   }
   *
   *   detached() {
   *   }
   *
   *   disposed() {
   *   }
   * }
   *
   * CustomComponent.RENDERER = MyRenderer;
   *
   * CustomComponent.STATE = {
   *   title: { value: 'Title' },
   *   fontSize: { value: '10px' }
   * };
   * </code>
   *
   * @extends {State}
   */
		var Component = function (_EventEmitter) {
			_inherits(Component, _EventEmitter);

			/**
    * Constructor function for `Component`.
    * @param {Object=} config An object with the initial values for this
    *     component's state.
    * @param {boolean|string|Element=} parentElement The element where the
    *     component should be rendered. Can be given as a selector or an element.
    *     If `false` is passed, the component won't be rendered automatically
    *     after created.
    * @constructor
    */
			function Component(config, parentElement) {
				_classCallCheck(this, Component);

				/**
     * Instance of `DomEventEmitterProxy` which proxies events from the component's
     * element to the component itself.
     * @type {!DomEventEmitterProxy}
     * @protected
     */
				var _this = _possibleConstructorReturn(this, (Component.__proto__ || Object.getPrototypeOf(Component)).call(this));

				_this.elementEventProxy_ = new _metalDom.DomEventEmitterProxy(null, _this, proxyBlackList_);

				/**
     * The `EventHandler` instance for events attached from the `events` state key.
     * @type {EventHandler}
     * @protected
     */
				_this.eventsStateKeyHandler_ = null;

				/**
     * Stores the pending callback function for when `forceUpdate` is used
     * to trigger a rerender.
     * @type {?function}
     */
				_this.forceUpdateCallback_ = null;

				/**
     * Whether the element is in document.
     * @type {boolean}
     */
				_this.inDocument = false;

				/**
     * The initial config option passed to this constructor.
     * @type {!Object}
     * @protected
     */
				_this.initialConfig_ = config || {};

				/**
     * Indicates whether the component should be rendered as a Portal, outside
     * of the parent component.
     * @type {string|Element|boolean}
     */
				_this.portalElement = null;

				/**
     * Whether the element was rendered.
     * @type {boolean}
     */
				_this.wasRendered = false;

				/**
     * The component's element will be appended to the element this variable is
     * set to, unless the user specifies another parent when calling `render` or
     * `attach`.
     * @type {!Element}
     */
				_this.DEFAULT_ELEMENT_PARENT = typeof document !== 'undefined' ? document.body : null;

				_this.setShouldUseFacade(true);
				_this.element = _this.initialConfig_.element;

				_this.setUpRenderer_();
				_this.setUpDataManager_();
				_this.setUpSyncUpdates_();

				_this.setUpPortal_(_this.initialConfig_.portalElement);

				_this.on('stateWillChange', _this.handleStateWillChange_);
				_this.on('stateChanged', _this.handleComponentStateChanged_);
				_this.on('eventsChanged', _this.onEventsChanged_);
				_this.addListenersFromObj_(_this.dataManager_.get(_this, 'events'));

				_this.created();
				_this.componentCreated_ = true;
				if (parentElement !== false) {
					_this.renderComponent(parentElement);
				}
				return _this;
			}

			/**
    * Getter logic for the element property.
    * @return {Element}
    */

			_createClass(Component, [{
				key: 'addListenersFromObj_',

				/**
     * Adds the listeners specified in the given object.
     * @param {!Object} obj
     * @protected
     */
				value: function addListenersFromObj_(obj) {
					var _eventsStateKeyHandle;

					if (!this.eventsStateKeyHandler_) {
						this.eventsStateKeyHandler_ = new _metalEvents.EventHandler();
					}
					var handles = (0, _events.addListenersFromObj)(this, obj);
					(_eventsStateKeyHandle = this.eventsStateKeyHandler_).add.apply(_eventsStateKeyHandle, _toConsumableArray(handles));
				}

				/**
     * Invokes the attached Lifecycle. When attached, the component element is
     * appended to the DOM and any other action to be performed must be
     * implemented in this method, such as, binding DOM events. A component can
     * be re-attached multiple times.
     * @param {(string|Element)=} parentElement Optional parent element
     *     to render the component.
     * @param {(string|Element)=} siblingElement Optional sibling element
     *     to render the component before it. Relevant when the component needs
     *     to be rendered before an existing element in the DOM.
     * @protected
     * @chainable
     * @return {Component}
     */

			}, {
				key: 'attach',
				value: function attach(parentElement, siblingElement) {
					if (!this.inDocument) {
						this.emit('willAttach');
						this.willAttach();
						this.attachElement(parentElement, siblingElement);
						this.inDocument = true;
						this.attachData_ = {
							parent: parentElement,
							sibling: siblingElement
						};
						this.emit('attached', this.attachData_);
						this.attached();
					}
					return this;
				}

				/**
     * Lifecycle. When attached, the component element is appended to the DOM
     * and any other action to be performed must be implemented in this method,
     * such as, binding DOM events. A component can be re-attached multiple
     * times, therefore the undo behavior for any action performed in this phase
     * must be implemented on the detach phase.
     */

			}, {
				key: 'attached',
				value: function attached() {}

				/**
     * Attaches the component element into the DOM.
     * @param {(string|Element)=} parentElement Optional parent element
     *     to render the component.
     * @param {(string|Element)=} siblingElement Optional sibling element
     *     to render the component before it. Relevant when the component needs
     *     to be rendered before an existing element in the DOM, e.g.
     *     `component.attach(null, existingElement)`.
     */

			}, {
				key: 'attachElement',
				value: function attachElement(parentElement, siblingElement) {
					var element = this.element;
					if (element && (siblingElement || !element.parentNode)) {
						var parent = (0, _metalDom.toElement)(parentElement) || this.DEFAULT_ELEMENT_PARENT; // eslint-disable-line
						parent.insertBefore(element, (0, _metalDom.toElement)(siblingElement));
					}
				}

				/**
     * Lifecycle. This is called when the component has just been created, before
     * it's rendered.
     */

			}, {
				key: 'created',
				value: function created() {}

				/**
     * Listens to a delegate event on the component's element.
     * @param {string} eventName The name of the event to listen to.
     * @param {string} selector The selector that matches the child elements that
     *   the event should be triggered for.
     * @param {!function(!Object)} callback Function to be called when the event is
     *   triggered. It will receive the normalized event object.
     * @return {!EventHandle} Can be used to remove the listener.
     */

			}, {
				key: 'delegate',
				value: function delegate(eventName, selector, callback) {
					return this.on('delegate:' + eventName + ':' + selector, callback);
				}

				/**
     * Invokes the detached Lifecycle. When detached, the component element is
     * removed from the DOM and any other action to be performed must be
     * implemented in this method, such as, unbinding DOM events. A component
     * can be detached multiple times.
     * @chainable
     * @return {Component}
     */

			}, {
				key: 'detach',
				value: function detach() {
					if (this.inDocument) {
						this.emit('willDetach');
						this.willDetach();
						if (this.element && this.element.parentNode) {
							this.element.parentNode.removeChild(this.element);
						}
						this.inDocument = false;
						this.detached();
					}
					this.emit('detached');
					return this;
				}

				/**
     * Lifecycle. When detached, the component element is removed from the DOM
     * and any other action to be performed must be implemented in this method,
     * such as, unbinding DOM events. A component can be detached multiple
     * times, therefore the undo behavior for any action performed in this phase
     * must be implemented on the attach phase.
     */

			}, {
				key: 'detached',
				value: function detached() {}

				/**
     * Lifecycle. Called when the component is disposed. Should be overridden by
     * sub classes to dispose of any internal data or events.
     */

			}, {
				key: 'disposed',
				value: function disposed() {}

				/**
     * @inheritDoc
     */

			}, {
				key: 'disposeInternal',
				value: function disposeInternal() {
					this.detach();
					this.disposed();
					this.emit('disposed');

					this.elementEventProxy_.dispose();
					this.elementEventProxy_ = null;

					this.dataManager_.dispose(this);
					this.dataManager_ = null;

					this.renderer_.dispose(this);
					this.renderer_ = null;

					_get(Component.prototype.__proto__ || Object.getPrototypeOf(Component.prototype), 'disposeInternal', this).call(this);
				}

				/**
     * Forces an update that ignores the `shouldUpdate` lifecycle method for
     * components whose render depends on external variables.
     * @param {function()} callback
     */

			}, {
				key: 'forceUpdate',
				value: function forceUpdate(callback) {
					this.forceUpdateCallback_ = callback;

					this.updateRenderer_({
						forceUpdate: true
					});
				}

				/**
     * Gets data about where this component was attached at.
     * @return {!Object}
     */

			}, {
				key: 'getAttachData',
				value: function getAttachData() {
					return this.attachData_;
				}

				/**
     * Gets the `ComponentDataManager` being used.
     * @return {!ComponentDataManager}
     */

			}, {
				key: 'getDataManager',
				value: function getDataManager() {
					return this.dataManager_;
				}

				/**
     * Gets the configuration object that was passed to this component's constructor.
     * @return {!Object}
     */

			}, {
				key: 'getInitialConfig',
				value: function getInitialConfig() {
					return this.initialConfig_;
				}

				/**
     * Gets portalElement based on selector. If an id is passed and the element
     * does not exist, the element is created with that id and appended to the body.
     *
     * @param {string|Element} portalElementSelector
     * @return {?Element}
     */

			}, {
				key: 'getPortalElement_',
				value: function getPortalElement_(portalElementSelector) {
					var portalElement = (0, _metalDom.toElement)(portalElementSelector);

					if (portalElement) {
						return portalElement;
					}

					if (portalElementSelector.indexOf('#') === 0 && portalElementSelector.indexOf(' ') === -1) {
						portalElement = document.createElement('div');
						portalElement.setAttribute('id', portalElementSelector.slice(1));

						(0, _metalDom.enterDocument)(portalElement);
					}

					return portalElement;
				}

				/**
     * Gets state data for this component.
     * @return {!Object}
     */

			}, {
				key: 'getState',
				value: function getState() {
					return this.dataManager_.getState(this);
				}

				/**
     * Gets the keys for the state data.
     * @return {!Array<string>}
     */

			}, {
				key: 'getStateKeys',
				value: function getStateKeys() {
					return this.dataManager_.getStateKeys(this);
				}

				/**
     * Gets the `ComponentRenderer` instance being used.
     * @return {!ComponentRenderer}
     */

			}, {
				key: 'getRenderer',
				value: function getRenderer() {
					return this.renderer_;
				}

				/**
     * Handles a change in the component's element.
     * @param {Element} prevVal
     * @param {Element} newVal
     * @protected
     */

			}, {
				key: 'handleComponentElementChanged_',
				value: function handleComponentElementChanged_(prevVal, newVal) {
					this.elementEventProxy_.setOriginEmitter(newVal);
					if (this.componentCreated_) {
						this.emit('elementChanged', {
							prevVal: prevVal,
							newVal: newVal
						});
						if (newVal && this.wasRendered) {
							this.syncVisible(this.dataManager_.get(this, 'visible'));
						}
					}
				}

				/**
     * Handles state batch changes. Calls any existing `sync` functions that
     * match the changed state keys.
     * @param {Event} event
     * @protected
     */

			}, {
				key: 'handleComponentStateChanged_',
				value: function handleComponentStateChanged_(event) {
					if (!this.hasSyncUpdates()) {
						this.updateRenderer_(event);
					}
					(0, _sync.syncState)(this, event.changes);
					this.emit('stateSynced', event);
				}

				/**
     * Handles a `stateKeyChanged` event. This is only called for components that
     * have requested updates to happen synchronously.
     * @param {!{key: string, newVal: *, prevVal: *}} data
     * @protected
     */

			}, {
				key: 'handleComponentStateKeyChanged_',
				value: function handleComponentStateKeyChanged_(data) {
					this.updateRenderer_({
						changes: _defineProperty({}, data.key, data)
					});
				}

				/**
     * Fires before state batch changes. Provides hook point for modifying
     *     state.
     * @param {Event} event
     * @protected
     */

			}, {
				key: 'handleStateWillChange_',
				value: function handleStateWillChange_(event) {
					this.willReceiveState(event.changes);
				}

				/**
     * Checks if this component has sync updates enabled.
     * @return {boolean}
     */

			}, {
				key: 'hasSyncUpdates',
				value: function hasSyncUpdates() {
					return this.syncUpdates_;
				}

				/**
     * Informs that the component that the rendered has finished rendering it. The
     * renderer is the one responsible for calling this when appropriate. This
     * will emit events and run the appropriate lifecycle for the first render.
     */

			}, {
				key: 'informRendered',
				value: function informRendered() {
					var firstRender = !this.hasRendererRendered_;
					this.hasRendererRendered_ = true;

					if (this.forceUpdateCallback_) {
						this.forceUpdateCallback_();
						this.forceUpdateCallback_ = null;
					}

					this.rendered(firstRender);
					this.emit('rendered', firstRender);
				}

				/**
     * Informs the component that the renderer is about to update. Calls the
     * component's `willUpdate` lifecycle method.
     * @param {Object} changes
     */

			}, {
				key: 'informWillUpdate',
				value: function informWillUpdate() {
					this.willUpdate.apply(this, arguments);
				}

				/**
     * Checks if the given function is a component constructor.
     * @param {!function()} fn Any function
     * @return {boolean}
     */

			}, {
				key: 'mergeElementClasses_',

				/**
     * Merges two values for the ELEMENT_CLASSES property into a single one.
     * @param {string} class1
     * @param {string} class2
     * @return {string} The merged value.
     * @protected
     */
				value: function mergeElementClasses_(class1, class2) {
					return class1 ? class1 + ' ' + (class2 || '') : class2;
				}

				/**
     * Fired when the `events` state value is changed.
     * @param {!Object} event
     * @protected
     */

			}, {
				key: 'onEventsChanged_',
				value: function onEventsChanged_(event) {
					this.eventsStateKeyHandler_.removeAllListeners();
					this.addListenersFromObj_(event.newVal);
				}

				/**
     * Creates and renders a component for the given constructor function. This
     * will always make sure that the constructor runs without rendering the
     * component, having the `render` step happen only after it has finished.
     * @param {!function()} Ctor The component's constructor function.
     * @param {Object|Element=} configOrElement Optional config data or parent
     *     for the component.
     * @param {Element=} element Optional parent for the component.
     * @return {!Component} The rendered component's instance.
     */

			}, {
				key: 'renderComponent',

				/**
     * Renders the component into the DOM via its `ComponentRenderer`. Stores the
     * given parent element to be used when the renderer is done (`informRendered`).
     * @param {(string|Element|boolean)=} parentElement Optional parent element
     *     to render the component. If set to `false`, the element won't be
     *     attached to any element after rendering. In this case, `attach` should
     *     be called manually later to actually attach it to the dom.
     */
				value: function renderComponent(parentElement) {
					if (!this.hasRendererRendered_) {
						if (!(0, _metal.isServerSide)() && window.__METAL_DEV_TOOLS_HOOK__) {
							window.__METAL_DEV_TOOLS_HOOK__(this);
						}
						this.getRenderer().render(this);
					}
					this.emit('render');
					(0, _sync.syncState)(this);
					this.attach(parentElement);
					this.wasRendered = true;
				}

				/**
     * Setter logic for the element property.
     * @param {?string|Element} val
     */

			}, {
				key: 'setState',

				/**
     * Sets the value of all the specified state keys.
     * @param {!Object.<string,*>} state A map of state keys to the values they
     *   should be set to.
     * @param {function()=} callback An optional function that will be run
     *   after the next batched update is triggered.
     */
				value: function setState(state, callback) {
					this.dataManager_.setState(this, state, callback);
				}

				/**
     * Setter for the `elementClasses` data property. Appends given value with
     * the one specified in `ELEMENT_CLASSES`.
     * @param {string} val
     * @return {string}
     * @protected
     */

			}, {
				key: 'setterElementClassesFn_',
				value: function setterElementClassesFn_(val) {
					var elementClasses = (0, _metal.getStaticProperty)(this.constructor, 'ELEMENT_CLASSES', this.mergeElementClasses_);
					if (elementClasses) {
						val += ' ' + elementClasses;
					}
					return val.trim();
				}

				/**
     * Sets up the component's data manager.
     * @protected
     */

			}, {
				key: 'setUpDataManager_',
				value: function setUpDataManager_() {
					this.dataManager_ = (0, _metal.getStaticProperty)(this.constructor, 'DATA_MANAGER');
					this.dataManager_.setUp(this, _metal.object.mixin({}, this.renderer_.getExtraDataConfig(this), Component.DATA) // eslint-disable-line
					);
				}

				/**
     * Overwrites element property if portalElement is passed. Creates
     * a nested placeholder so that portalElement is not removed from the
     * DOM when component first renders. When portalElement is equal to true,
     * component is appeneded to the body.
     *
     * @param {string|Element|boolean} portalElement
     */

			}, {
				key: 'setUpPortal_',
				value: function setUpPortal_(portalElement) {
					if (!portalElement || !(0, _metal.isElement)(portalElement) && !(0, _metal.isString)(portalElement) && !(0, _metal.isBoolean)(portalElement)) {
						return;
					} else if ((0, _metal.isBoolean)(portalElement) && portalElement) {
						portalElement = 'body';
					}

					if ((0, _metal.isServerSide)()) {
						this.portalElement = true;
						return;
					}

					portalElement = this.getPortalElement_(portalElement);

					if (portalElement) {
						var placeholder = document.createElement('div');

						portalElement.appendChild(placeholder);

						this.element = placeholder;
						this.portalElement = portalElement;
					}
				}

				/**
     * Sets up the component's renderer.
     * @protected
     */

			}, {
				key: 'setUpRenderer_',
				value: function setUpRenderer_() {
					this.renderer_ = (0, _metal.getStaticProperty)(this.constructor, 'RENDERER');
					this.renderer_.setUp(this);
				}

				/**
     * Sets up the component to use sync updates when `SYNC_UPDATES` is `true`.
     * @protected
     */

			}, {
				key: 'setUpSyncUpdates_',
				value: function setUpSyncUpdates_() {
					this.syncUpdates_ = (0, _metal.getStaticProperty)(this.constructor, 'SYNC_UPDATES');
					if (this.hasSyncUpdates()) {
						this.on('stateKeyChanged', this.handleComponentStateKeyChanged_.bind(this));
					}
				}

				/**
     * Skips renderer updates until `stopSkipUpdates` is called.
     */

			}, {
				key: 'startSkipUpdates',
				value: function startSkipUpdates() {
					this.skipUpdates_ = true;
				}

				/**
     * Stops skipping renderer updates.
     */

			}, {
				key: 'stopSkipUpdates',
				value: function stopSkipUpdates() {
					this.skipUpdates_ = false;
				}

				/**
     * State synchronization logic for `visible` state key.
     * Updates the element's display value according to its visibility.
     * @param {boolean} newVal
     */

			}, {
				key: 'syncVisible',
				value: function syncVisible(newVal) {
					if (this.element) {
						this.element.style.display = newVal ? '' : 'none';
					}
				}

				/**
     * Lifecycle. Called whenever the component has just been rendered.
     * @param {boolean} firstRender Flag indicating if this was the component's
     *     first render.
     */

			}, {
				key: 'rendered',
				value: function rendered() {}

				/**
     * Calls "update" on the renderer, passing it the changed data.
     * @param {!{changes: !Object}} data
     * @protected
     */

			}, {
				key: 'updateRenderer_',
				value: function updateRenderer_(data) {
					if (!data.forceUpdate) {
						this.forceUpdateCallback_ = null;
					}

					if (!this.skipUpdates_ && this.hasRendererRendered_) {
						this.getRenderer().update(this, data);
					}
				}

				/**
     * Validator logic for the `events` state key.
     * @param {Object} val
     * @return {boolean}
     * @protected
     */

			}, {
				key: 'validatorEventsFn_',
				value: function validatorEventsFn_(val) {
					return !(0, _metal.isDefAndNotNull)(val) || (0, _metal.isObject)(val);
				}

				/**
     * Lifecycle. Fires before the component has been attached to the DOM.
     */

			}, {
				key: 'willAttach',
				value: function willAttach() {}

				/**
     * Lifecycle. Fires before component is detached from the DOM.
     */

			}, {
				key: 'willDetach',
				value: function willDetach() {}

				/**
     * Lifecycle. Called when the component is about to receive state changes.
     * Provides a hook point for modifying state that can be used in the next
     * rerender.
     * @param {Object} changes Changes made to this.state
     */

			}, {
				key: 'willReceiveState',
				value: function willReceiveState() {}

				/**
     * Lifecycle. Called when the component's renderer is about to update.
     * @param {Object} changes
     */

			}, {
				key: 'willUpdate',
				value: function willUpdate() {}
			}, {
				key: 'element',
				get: function get() {
					return this.elementValue_;
				},
				set: function set(val) {
					if (!(0, _metal.isElement)(val) && !(0, _metal.isString)(val) && (0, _metal.isDefAndNotNull)(val)) {
						return;
					}

					if (val) {
						val = (0, _metalDom.toElement)(val) || this.elementValue_;
					}

					if (this.elementValue_ !== val) {
						var prev = this.elementValue_;
						this.elementValue_ = val;
						this.handleComponentElementChanged_(prev, val);
					}
				}
			}], [{
				key: 'isComponentCtor',
				value: function isComponentCtor(fn) {
					return fn.prototype && fn.prototype[Component.COMPONENT_FLAG];
				}
			}, {
				key: 'render',
				value: function render(Ctor, configOrElement, element) {
					var config = configOrElement;
					if ((0, _metal.isElement)(configOrElement)) {
						config = null;
						element = configOrElement;
					}
					var instance = new Ctor(config, false);
					instance.renderComponent(element);
					return instance;
				}

				/**
     * Creates and renders a component for the given constructor function as
     * string. This will always make sure that the constructor runs without
     * rendering the component, having the `render` step happen only after it
     * has finished.
     * @param {!function()} Ctor The component's constructor function.
     * @param {Object|Element=} configOrElement Optional config data or
     *     parent for the component.
     * @return {!String} The rendered component's content as string.
     */

			}, {
				key: 'renderToString',
				value: function renderToString(Ctor, configOrElement) {
					var rendererName = Ctor.RENDERER && Ctor.RENDERER.RENDERER_NAME;
					switch (rendererName) {
						case 'jsx':
						case 'soy':
						case 'incremental-dom':
							{
								if (typeof IncrementalDOM === 'undefined') {
									throw new Error('Error. Trying to render incremental dom ' + 'based component to string requires IncrementalDOM ' + 'implementation to be loaded.');
								}
								// Incremental dom patches for components or nested components are
								// isolated inside the component element. The following code intercepts
								// incremental dom patches and collect results into temporary stack in
								// order to successfully collect the final string of the outermost
								// component after all nested components stack rendered.
								var interceptedComponentStrings = [];
								var patch = IncrementalDOM.patch;
								var patchInterceptor = function patchInterceptor() {
									var currentElement = patch.apply(undefined, arguments);
									interceptedComponentStrings.push(currentElement.innerHTML);
									IncrementalDOM.patch = patch;
								};
								IncrementalDOM.patch = patchInterceptor;
								Component.render(Ctor, configOrElement).dispose();
								return interceptedComponentStrings[0];
							}
						default:
							throw new Error('Error. Trying to render non incremental dom ' + 'based component to string.');
					}
				}
			}]);

			return Component;
		}(_metalEvents.EventEmitter);

		/**
   * Component data definition.
   * @type {Object}
   * @static
   */

		Component.DATA = {
			/**
    * Objects describing children elements that were passed to be rendered inside
    * this component.
    * @type {!Array<!Object>}
    */
			children: {
				validator: Array.isArray,
				value: []
			},

			/**
    * CSS classes to be applied to the element.
    * @type {string}
    */
			elementClasses: {
				setter: 'setterElementClassesFn_',
				validator: _metal.isString,
				value: ''
			},

			/**
    * Listeners that should be attached to this component. Should be provided as
    * an object, where the keys are event names and the values are the listener
    * functions (or function names).
    * @type {Object<string, (function()|string|{selector: string, fn: function()|string})>}
    */
			events: {
				validator: 'validatorEventsFn_',
				value: null
			},

			/**
    * Indicates if the component is visible or not.
    * @type {boolean}
    */
			visible: {
				validator: _metal.isBoolean,
				value: true
			}
		};

		/**
   * Name of the flag used to identify component constructors via their prototype.
   * @type {string}
   */
		Component.COMPONENT_FLAG = '__metal_component__';

		/**
   * The `ComponentDataManager` class that should be used. This class will be
   * responsible for handling the component's data. Each component may have its
   * own implementation.
   * @type {!ComponentDataManager}
   */
		Component.DATA_MANAGER = _ComponentDataManager2.default;

		/**
   * CSS classes to be applied to the element.
   * @type {string}
   */
		Component.ELEMENT_CLASSES = '';

		/**
   * The `ComponentRenderer` that should be used. Components need to set this
   * to a subclass of `ComponentRenderer` that has the rendering logic, like
   * `SoyRenderer`.
   * @type {!ComponentRenderer}
   */
		Component.RENDERER = _ComponentRenderer2.default;

		/**
   * Flag indicating if component updates will happen synchronously. Updates are
   * done asynchronously by default, which allows changes to be batched and
   * applied together.
   * @type {boolean}
   */
		Component.SYNC_UPDATES = false;

		/**
   * Sets a prototype flag to easily determine if a given constructor is for
   * a component or not.
   */
		Component.prototype[Component.COMPONENT_FLAG] = true;

		var proxyBlackList_ = {
			eventsChanged: true,
			stateChanged: true,
			stateKeyChanged: true
		};

		exports.default = Component;
		//# sourceMappingURL=Component.js.map
	}
});
//# sourceMappingURL=Component.js.map
'use strict';

Liferay.Loader.define("frontend-js-metal-web$metal-component@2.16.8/lib/ComponentRegistry", ['module', 'exports', 'require', 'frontend-js-metal-web$metal'], function (module, exports, require) {
	var define = undefined;
	var global = window;
	{
		Object.defineProperty(exports, "__esModule", {
			value: true
		});

		var _createClass = function () {
			function defineProperties(target, props) {
				for (var i = 0; i < props.length; i++) {
					var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
				}
			}return function (Constructor, protoProps, staticProps) {
				if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
			};
		}();

		var _metal = require("frontend-js-metal-web$metal");

		function _classCallCheck(instance, Constructor) {
			if (!(instance instanceof Constructor)) {
				throw new TypeError("Cannot call a class as a function");
			}
		}

		/**
   * The component registry is used to register components, so they can
   * be accessible by name.
   * @type {Object}
   */
		var ComponentRegistry = function () {
			function ComponentRegistry() {
				_classCallCheck(this, ComponentRegistry);
			}

			_createClass(ComponentRegistry, null, [{
				key: 'getConstructor',

				/**
     * Gets the constructor function for the given component name, or
     * undefined if it hasn't been registered yet.
     * @param {string} name The component's name.
     * @return {?function()}
     * @static
     */
				value: function getConstructor(name) {
					var constructorFn = ComponentRegistry.components_[name];
					if (!constructorFn) {
						console.error('There\'s no constructor registered for the component named ' + name + '.\n\t\t\t\tComponents need to be registered via ComponentRegistry.register.');
					}
					return constructorFn;
				}

				/**
     * Registers a component, so it can be found by its name.
     * @param {!Function} constructorFn The component's constructor function.
     * @param {string=} name Name of the registered component. If none is given
     *   the name defined by the NAME static variable will be used instead. If that
     *   isn't set as well, the name of the constructor function will be used.
     * @static
     */

			}, {
				key: 'register',
				value: function register(constructorFn, name) {
					if (!name) {
						if (constructorFn.hasOwnProperty('NAME')) {
							name = constructorFn.NAME;
						} else {
							name = (0, _metal.getFunctionName)(constructorFn);
						}
					}
					constructorFn.NAME = name;
					ComponentRegistry.components_[name] = constructorFn;
				}
			}]);

			return ComponentRegistry;
		}();

		/**
   * Holds all registered components, indexed by their names.
   * @type {!Object<string, function()>}
   * @protected
   * @static
   */

		ComponentRegistry.components_ = {};

		exports.default = ComponentRegistry;
		//# sourceMappingURL=ComponentRegistry.js.map
	}
});
//# sourceMappingURL=ComponentRegistry.js.map
'use strict';

Liferay.Loader.define('frontend-js-metal-web$metal-component@2.16.8/lib/all/component', ['module', 'exports', 'require', '../events/events', '../Component', '../ComponentDataManager', '../ComponentRegistry', '../ComponentRenderer'], function (module, exports, require) {
	var define = undefined;
	var global = window;
	{
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.ComponentRenderer = exports.ComponentRegistry = exports.ComponentDataManager = exports.Component = undefined;

		var _events = require('../events/events');

		Object.keys(_events).forEach(function (key) {
			if (key === "default" || key === "__esModule") return;
			Object.defineProperty(exports, key, {
				enumerable: true,
				get: function get() {
					return _events[key];
				}
			});
		});

		var _Component = require('../Component');

		var _Component2 = _interopRequireDefault(_Component);

		var _ComponentDataManager = require('../ComponentDataManager');

		var _ComponentDataManager2 = _interopRequireDefault(_ComponentDataManager);

		var _ComponentRegistry = require('../ComponentRegistry');

		var _ComponentRegistry2 = _interopRequireDefault(_ComponentRegistry);

		var _ComponentRenderer = require('../ComponentRenderer');

		var _ComponentRenderer2 = _interopRequireDefault(_ComponentRenderer);

		function _interopRequireDefault(obj) {
			return obj && obj.__esModule ? obj : { default: obj };
		}

		exports.default = _Component2.default;
		exports.Component = _Component2.default;
		exports.ComponentDataManager = _ComponentDataManager2.default;
		exports.ComponentRegistry = _ComponentRegistry2.default;
		exports.ComponentRenderer = _ComponentRenderer2.default;
		//# sourceMappingURL=component.js.map
	}
});
//# sourceMappingURL=component.js.map
Liferay.Loader.define("frontend-js-web@4.0.38/liferay/PortletBase.es", ['module', 'exports', 'require', 'frontend-js-metal-web$metal', 'frontend-js-metal-web$metal-component', 'frontend-js-metal-web$metal-dom', './util/form/object_to_form_data.es'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _metal = _interopRequireDefault(require("frontend-js-metal-web$metal"));

    var _metalComponent = _interopRequireDefault(require("frontend-js-metal-web$metal-component"));

    var _metalDom = _interopRequireDefault(require("frontend-js-metal-web$metal-dom"));

    var _object_to_form_data = _interopRequireDefault(require("./util/form/object_to_form_data.es"));

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof(obj) {
          return typeof obj;
        };
      } else {
        _typeof = function _typeof(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }return _typeof(obj);
    }

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
    }

    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }return _assertThisInitialized(self);
    }

    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }return self;
    }

    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };return _getPrototypeOf(o);
    }

    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);
    }

    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;return o;
      };return _setPrototypeOf(o, p);
    }

    /**
     * Provides helper functions that simplify querying the DOM for elements related
     * to a specific portlet.
     *
     * @abstract
     * @extends {Component}
     */
    var PortletBase = /*#__PURE__*/function (_Component) {
      _inherits(PortletBase, _Component);

      function PortletBase() {
        _classCallCheck(this, PortletBase);

        return _possibleConstructorReturn(this, _getPrototypeOf(PortletBase).apply(this, arguments));
      }

      _createClass(PortletBase, [{
        key: "all",

        /**
         * Returns a Node List containing all the matching element nodes within the
         * subtrees of the root object, in tree order. If there are no matching
         * nodes, the method returns an empty Node List.
         *
         * @param  {string} selectors A list of one or more CSS relative selectors.
         * @param  {(string|Element|Document)=} root The root node of the search. If
         *         not specified, the element search will start in the portlet's
         *         root node or in the document.
         * @return {NodeList<Element>} A list of elements matching the selectors, in
         *         tree order.
         */
        value: function all(selectors, root) {
          root = _metalDom.default.toElement(root) || this.rootNode || document;
          return root.querySelectorAll(this.namespaceSelectors_(this.portletNamespace || this.namespace, selectors));
        }
        /**
         * Performs an HTTP POST request to the given URL with the given body.
         *
         * @deprecated As of Athanasius (7.3.x), replaced by `Liferay.Util.fetch`.
         * @param      {!string} url The URL to send the post request to.
         * @param      {!Object|!FormData} body The request body.
         * @return     {Promise} A promise.
         */

      }, {
        key: "fetch",
        value: function (_fetch) {
          function fetch(_x, _x2) {
            return _fetch.apply(this, arguments);
          }

          fetch.toString = function () {
            return _fetch.toString();
          };

          return fetch;
        }(function (url, body) {
          var requestBody = this.getRequestBody_(body); // eslint-disable-next-line @liferay/portal/no-global-fetch

          return fetch(url, {
            body: requestBody,
            credentials: 'include',
            method: 'POST'
          });
        })
        /**
         * Transforms the given body into a valid <code>FormData</code> element.
         *
         * @param  {!FormData|!HTMLFormElement|!Object} body The original data.
         * @return {FormData} The transformed form data.
         */

      }, {
        key: "getRequestBody_",
        value: function getRequestBody_(body) {
          var requestBody;

          if (body instanceof FormData) {
            requestBody = body;
          } else if (body instanceof HTMLFormElement) {
            requestBody = new FormData(body);
          } else if (_typeof(body) === 'object') {
            requestBody = (0, _object_to_form_data.default)(this.ns(body));
          } else {
            requestBody = body;
          }

          return requestBody;
        }
        /**
         * Namespaces the list of selectors, appending the portlet namespace to the
         * selectors of type ID. Selectors of other types remain unaltered.
         *
         * @param {string} namespace The portlet's namespace.
         * @param {string} selectors A list of one or more CSS relative selectors.
         * @protected
         * @return {string} The namespaced ID selectors.
         */

      }, {
        key: "namespaceSelectors_",
        value: function namespaceSelectors_(namespace, selectors) {
          return selectors.replace(new RegExp('(#|\\[id=(\\"|\\\'))(?!' + namespace + ')', 'g'), '$1' + namespace);
        }
        /**
         * Appends the portlet's namespace to the given string or object properties.
         *
         * @param  {!Object|string} obj The object or string to namespace.
         * @return {Object|string} An object with its properties namespaced, using
         *         the portlet namespace or a namespaced string.
         */

      }, {
        key: "ns",
        value: function ns(obj) {
          return Liferay.Util.ns(this.portletNamespace || this.namespace, obj);
        }
        /**
         * Returns the first matching Element node within the subtrees of the
         * root object. If there is no matching Element, the method returns null.
         *
         * @param  {string} selectors A list of one or more CSS relative selectors.
         * @param  {(string|Element|Document)=} root The root node of the search. If
         *         not specified, the element search will start in the portlet's
         *         root node or in the document.
         * @return {Element|null} A list of the first element matching the selectors
         *         or <code>null</code>.
         */

      }, {
        key: "one",
        value: function one(selectors, root) {
          root = _metalDom.default.toElement(root) || this.rootNode || document;
          return root.querySelector(this.namespaceSelectors_(this.portletNamespace || this.namespace, selectors));
        }
        /**
         * Returns the default portlet root node element. By default, this is the
         * element with ID <code>p_p_id{portletNamespace}</code>.
         *
         * @protected
         * @return {Element} The portlet's default root node element.
         */

      }, {
        key: "rootNodeValueFn_",
        value: function rootNodeValueFn_() {
          return _metalDom.default.toElement("#p_p_id".concat(this.portletNamespace || this.namespace));
        }
      }]);

      return PortletBase;
    }(_metalComponent.default);
    /**
     * State definition.
     *
     * @ignore
     * @static
     * @type {!Object}
     */

    PortletBase.STATE = {
      /**
       * Portlet's namespace.
       *
       * @deprecated As of Judson (7.1.x)
       * @instance
       * @memberof PortletBase
       * @type {string}
       */
      namespace: {
        validator: _metal.default.isString
      },

      /**
       * Portlet's namespace.
       *
       * @instance
       * @memberof PortletBase
       * @type {string}
       */
      portletNamespace: {
        validator: _metal.default.isString
      },

      /**
       * Portlet's root node element.
       *
       * @instance
       * @memberof PortletBase
       * @type {Element}
       */
      rootNode: {
        setter: _metalDom.default.toElement,
        valueFn: 'rootNodeValueFn_'
      }
    };
    var _default = PortletBase;
    exports.default = _default;
    //# sourceMappingURL=PortletBase.es.js.map
  }
});
//# sourceMappingURL=PortletBase.es.js.map
Liferay.Loader.define("frontend-js-web@4.0.38/liferay/DefaultEventHandler.es", ['module', 'exports', 'require', './PortletBase.es'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _PortletBase2 = _interopRequireDefault(require("./PortletBase.es"));

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof(obj) {
          return typeof obj;
        };
      } else {
        _typeof = function _typeof(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }return _typeof(obj);
    }

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
    }

    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }return _assertThisInitialized(self);
    }

    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }return self;
    }

    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };return _getPrototypeOf(o);
    }

    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);
    }

    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;return o;
      };return _setPrototypeOf(o, p);
    }

    var DefaultEventHandler = /*#__PURE__*/function (_PortletBase) {
      _inherits(DefaultEventHandler, _PortletBase);

      function DefaultEventHandler() {
        _classCallCheck(this, DefaultEventHandler);

        return _possibleConstructorReturn(this, _getPrototypeOf(DefaultEventHandler).apply(this, arguments));
      }

      _createClass(DefaultEventHandler, [{
        key: "callAction",
        value: function callAction(event) {
          var itemData = event.data.item.data;

          if (itemData && itemData.action && this[itemData.action]) {
            this[itemData.action](itemData);
          }
        }
      }, {
        key: "handleActionItemClicked",
        value: function handleActionItemClicked(event) {
          this.callAction(event);
        }
      }, {
        key: "handleCreationButtonClicked",
        value: function handleCreationButtonClicked(event) {
          var itemData = event.data.data;

          if (itemData && itemData.action && this[itemData.action]) {
            this[itemData.action](itemData);
          }
        }
      }, {
        key: "handleCreationMenuItemClicked",
        value: function handleCreationMenuItemClicked(event) {
          this.callAction(event);
        }
      }, {
        key: "handleFilterItemClicked",
        value: function handleFilterItemClicked(event) {
          this.callAction(event);
        }
      }, {
        key: "handleItemClicked",
        value: function handleItemClicked(event) {
          this.callAction(event);
        }
      }]);

      return DefaultEventHandler;
    }(_PortletBase2.default);

    var _default = DefaultEventHandler;
    exports.default = _default;
    //# sourceMappingURL=DefaultEventHandler.es.js.map
  }
});
//# sourceMappingURL=DefaultEventHandler.es.js.map
Liferay.Loader.define('frontend-js-web@4.0.38/liferay/util/toggle_disabled', ['module', 'exports', 'require'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toggleDisabled;

    /**
     * Copyright (c) 2000-present Liferay, Inc. All rights reserved.
     *
     * This library is free software; you can redistribute it and/or modify it under
     * the terms of the GNU Lesser General Public License as published by the Free
     * Software Foundation; either version 2.1 of the License, or (at your option)
     * any later version.
     *
     * This library is distributed in the hope that it will be useful, but WITHOUT
     * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
     * details.
     */

    /**
     * Toggles disabled class on received element
     * @param nodes
     * @param state
     */
    function toggleDisabled(nodes, state) {
      if (typeof nodes === 'string') {
        nodes = document.querySelectorAll(nodes);
      } else if (nodes._node) {
        nodes = [nodes._node];
      } else if (nodes._nodes) {
        nodes = nodes._nodes;
      } else if (nodes.nodeType === Node.ELEMENT_NODE) {
        nodes = [nodes];
      }

      nodes.forEach(function (node) {
        node.disabled = state;

        if (state) {
          node.classList.add('disabled');
        } else {
          node.classList.remove('disabled');
        }
      });
    }
    //# sourceMappingURL=toggle_disabled.js.map
  }
});
//# sourceMappingURL=toggle_disabled.js.map
Liferay.Loader.define("frontend-js-web@4.0.38/liferay/ItemSelectorDialog.es", ['module', 'exports', 'require', 'frontend-js-metal-web$metal-component', 'frontend-js-metal-web$metal-state', './util/toggle_disabled'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _metalComponent = _interopRequireDefault(require("frontend-js-metal-web$metal-component"));

    var _metalState = require("frontend-js-metal-web$metal-state");

    var _toggle_disabled = _interopRequireDefault(require("./util/toggle_disabled"));

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof(obj) {
          return typeof obj;
        };
      } else {
        _typeof = function _typeof(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }return _typeof(obj);
    }

    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);if (enumerableOnly) symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });keys.push.apply(keys, symbols);
      }return keys;
    }

    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};if (i % 2) {
          ownKeys(Object(source), true).forEach(function (key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function (key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }return target;
    }

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }return obj;
    }

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
    }

    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }return _assertThisInitialized(self);
    }

    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }return self;
    }

    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };return _getPrototypeOf(o);
    }

    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);
    }

    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;return o;
      };return _setPrototypeOf(o, p);
    }

    /**
     * Shows a dialog and handles the selected item.
     */
    var ItemSelectorDialog = /*#__PURE__*/function (_Component) {
      _inherits(ItemSelectorDialog, _Component);

      function ItemSelectorDialog() {
        _classCallCheck(this, ItemSelectorDialog);

        return _possibleConstructorReturn(this, _getPrototypeOf(ItemSelectorDialog).apply(this, arguments));
      }

      _createClass(ItemSelectorDialog, [{
        key: "close",

        /**
         * Closes the dialog.
         */
        value: function close() {
          Liferay.Util.getWindow(this.eventName).hide();
        }
        /**
         * Opens the dialog.
         */

      }, {
        key: "open",
        value: function open() {
          var _this = this;

          this._currentItem = null;
          this._selectedItem = null;
          var eventName = this.eventName;

          var dialogConfig = this._getDialogConfig();

          Liferay.Util.selectEntity({
            dialog: _objectSpread(_objectSpread({}, dialogConfig), {
              on: {
                click: function click(event) {
                  event.domEvent.preventDefault();
                },
                visibleChange: function visibleChange(event) {
                  if (!event.newVal) {
                    _this.selectedItem = _this._selectedItem;

                    _this.emit('selectedItemChange', {
                      selectedItem: _this.selectedItem
                    });
                  }

                  _this.emit('visibleChange', {
                    visible: event.newVal
                  });
                }
              }
            }),
            eventName: eventName,
            id: eventName,
            stack: !this.zIndex,
            title: this.title,
            uri: this.url
          }, this._onItemSelected.bind(this));
        }
      }, {
        key: "_getDialogConfig",
        value: function _getDialogConfig() {
          var _this2 = this;

          var dialogConfig = {
            constrain: true,
            cssClass: this.dialogClasses,
            destroyOnHide: true,
            modal: true,
            zIndex: this.zIndex
          };

          if (!this.singleSelect) {
            var dialogFooter = [{
              cssClass: 'btn-secondary close-modal',
              id: 'cancelButton',
              label: this.buttonCancelLabel,
              on: {
                click: function click() {
                  _this2.close();
                }
              }
            }, {
              cssClass: 'btn-primary',
              disabled: true,
              id: 'addButton',
              label: this.buttonAddLabel,
              on: {
                click: function click() {
                  _this2._selectedItem = _this2._currentItem;

                  _this2.close();
                }
              }
            }];
            dialogConfig['toolbars.footer'] = dialogFooter;
          }

          return dialogConfig;
        }
        /**
         * Saves the current selected item in the dialog and disables the Add
         * button.
         *
         * @param {EventFacade} event The event.
         * @private
         */

      }, {
        key: "_onItemSelected",
        value: function _onItemSelected(event) {
          var currentItem = event.data;

          if (this.singleSelect) {
            this._selectedItem = currentItem;
            this.close();
          } else {
            var dialog = Liferay.Util.getWindow(this.eventName);
            var addButton = dialog.getToolbar('footer').get('boundingBox').one('#addButton');
            (0, _toggle_disabled.default)(addButton, !currentItem);
          }

          this._currentItem = currentItem;
        }
      }]);

      return ItemSelectorDialog;
    }(_metalComponent.default);
    /**
     * State definition.
     *
     * @static
     * @type {!Object}
     */

    ItemSelectorDialog.STATE = {
      /**
       * Label for the Add button.
       *
       * @instance
       * @memberof ItemSelectorDialog
       * @type {String}
       */
      buttonAddLabel: _metalState.Config.string().value('Add'),

      /**
       * Label for the Cancel button.
       *
       * @instance
       * @memberof ItemSelectorDialog
       * @type {String}
       */
      buttonCancelLabel: _metalState.Config.string().value('Cancel'),

      /**
       * CSS classes to pass to the dialog.
       *
       * @instance
       * @memberof ItemSelectorDialog
       * @type {String}
       */
      dialogClasses: _metalState.Config.string(),

      /**
       * Event name.
       *
       * @instance
       * @memberof ItemSelectorDialog
       * @type {String}
       */
      eventName: _metalState.Config.string().required(),

      /**
       * The selected item(s) in the dialog.
       *
       * @instance
       * @memberof ItemSelectorDialog
       * @type {Object|Object[]}
       */
      selectedItem: _metalState.Config.oneOfType([_metalState.Config.object(), _metalState.Config.arrayOf(_metalState.Config.object())]),

      /**
       * Enables single selection of item.
       * @type {boolean}
       */
      singleSelect: _metalState.Config.bool().value(false),

      /**
       * Dialog's title.
       *
       * @instance
       * @memberof ItemSelectorDialog
       * @type {String}
       */
      title: _metalState.Config.string().value('Select\x20File'),

      /**
       * URL that opens the dialog.
       *
       * @instance
       * @memberof ItemSelectorDialog
       * @type {String}
       */
      url: _metalState.Config.string().required(),

      /**
       * Dialog's zIndex.
       *
       * @instance
       * @memberof ItemSelectorDialog
       * @type {Number}
       */
      zIndex: _metalState.Config.number()
    };
    var _default = ItemSelectorDialog;
    exports.default = _default;
    //# sourceMappingURL=ItemSelectorDialog.es.js.map
  }
});
//# sourceMappingURL=ItemSelectorDialog.es.js.map
"use strict";

Liferay.Loader.define("@frontend-taglib-clay$clayui/button@3.5.0/lib/Group", ['module', 'exports', 'require', 'frontend-taglib-clay$classnames', 'frontend-js-react-web$react'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _classnames = _interopRequireDefault(require("frontend-taglib-clay$classnames"));

    var _react = _interopRequireDefault(require("frontend-js-react-web$react"));

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    function _extends() {
      _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };return _extends.apply(this, arguments);
    }

    function _objectWithoutProperties(source, excluded) {
      if (source == null) return {};var target = _objectWithoutPropertiesLoose(source, excluded);var key, i;if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];if (excluded.indexOf(key) >= 0) continue;if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;target[key] = source[key];
        }
      }return target;
    }

    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null) return {};var target = {};var sourceKeys = Object.keys(source);var key, i;for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];if (excluded.indexOf(key) >= 0) continue;target[key] = source[key];
      }return target;
    }

    var ClayButtonGroup = function ClayButtonGroup(_ref) {
      var children = _ref.children,
          className = _ref.className,
          _ref$role = _ref.role,
          role = _ref$role === void 0 ? 'group' : _ref$role,
          spaced = _ref.spaced,
          otherProps = _objectWithoutProperties(_ref, ["children", "className", "role", "spaced"]);

      return (/*#__PURE__*/_react.default.createElement("div", _extends({}, otherProps, {
          className: (0, _classnames.default)(className, 'btn-group'),
          role: role
        }), spaced ? _react.default.Children.map(children, function (child, i) {
          return (/*#__PURE__*/_react.default.cloneElement( /*#__PURE__*/_react.default.createElement("div", {
              className: "btn-group-item"
            }, child), {
              key: i
            })
          );
        }) : children)
      );
    };

    var _default = ClayButtonGroup;
    exports.default = _default;
  }
});
//# sourceMappingURL=Group.js.map
"use strict";

Liferay.Loader.define("@frontend-taglib-clay$clayui/button@3.5.0/lib/Button", ['module', 'exports', 'require', 'frontend-taglib-clay$classnames', 'frontend-js-react-web$react', './Group'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _classnames = _interopRequireDefault(require("frontend-taglib-clay$classnames"));

    var _react = _interopRequireDefault(require("frontend-js-react-web$react"));

    var _Group = _interopRequireDefault(require("./Group"));

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    function _extends() {
      _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };return _extends.apply(this, arguments);
    }

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }return obj;
    }

    function _objectWithoutProperties(source, excluded) {
      if (source == null) return {};var target = _objectWithoutPropertiesLoose(source, excluded);var key, i;if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];if (excluded.indexOf(key) >= 0) continue;if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;target[key] = source[key];
        }
      }return target;
    }

    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null) return {};var target = {};var sourceKeys = Object.keys(source);var key, i;for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];if (excluded.indexOf(key) >= 0) continue;target[key] = source[key];
      }return target;
    }

    var ClayButton = /*#__PURE__*/_react.default.forwardRef(function (_ref, ref) {
      var _classNames;

      var alert = _ref.alert,
          block = _ref.block,
          borderless = _ref.borderless,
          children = _ref.children,
          className = _ref.className,
          _ref$displayType = _ref.displayType,
          displayType = _ref$displayType === void 0 ? 'primary' : _ref$displayType,
          monospaced = _ref.monospaced,
          outline = _ref.outline,
          small = _ref.small,
          _ref$type = _ref.type,
          type = _ref$type === void 0 ? 'button' : _ref$type,
          otherProps = _objectWithoutProperties(_ref, ["alert", "block", "borderless", "children", "className", "displayType", "monospaced", "outline", "small", "type"]);

      return (/*#__PURE__*/_react.default.createElement("button", _extends({
          className: (0, _classnames.default)(className, 'btn', (_classNames = {
            'alert-btn': alert,
            'btn-block': block,
            'btn-monospaced': monospaced,
            'btn-outline-borderless': borderless,
            'btn-sm': small
          }, _defineProperty(_classNames, "btn-".concat(displayType), displayType && !outline && !borderless), _defineProperty(_classNames, "btn-outline-".concat(displayType), displayType && (outline || borderless)), _classNames)),
          ref: ref,
          type: type
        }, otherProps), children)
      );
    });

    ClayButton.displayName = 'ClayButton';

    var _default = Object.assign(ClayButton, {
      Group: _Group.default
    });

    exports.default = _default;
  }
});
//# sourceMappingURL=Button.js.map
