'use strict';

/**
 * A collection of core utility functions.
 * @const
 */

Liferay.Loader.define("frontend-js-metal-web$metal@2.16.8/lib/coreNamed", ['module', 'exports', 'require'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    exports.abstractMethod = abstractMethod;
    exports.disableCompatibilityMode = disableCompatibilityMode;
    exports.enableCompatibilityMode = enableCompatibilityMode;
    exports.getCompatibilityModeData = getCompatibilityModeData;
    exports.getFunctionName = getFunctionName;
    exports.getStaticProperty = getStaticProperty;
    exports.getUid = getUid;
    exports.identityFunction = identityFunction;
    exports.isBoolean = isBoolean;
    exports.isDef = isDef;
    exports.isDefAndNotNull = isDefAndNotNull;
    exports.isDocument = isDocument;
    exports.isDocumentFragment = isDocumentFragment;
    exports.isElement = isElement;
    exports.isFunction = isFunction;
    exports.isNull = isNull;
    exports.isNumber = isNumber;
    exports.isWindow = isWindow;
    exports.isObject = isObject;
    exports.isPromise = isPromise;
    exports.isString = isString;
    exports.isServerSide = isServerSide;
    exports.nullFunction = nullFunction;
    var compatibilityModeData_ = void 0;

    /**
     * Counter for unique id.
     * @type {Number}
     * @private
     */
    var uniqueIdCounter_ = 1;

    /**
     * Unique id property prefix.
     * @type {String}
     * @protected
     */
    var UID_PROPERTY = exports.UID_PROPERTY = 'core_' + (Math.random() * 1e9 >>> 0);

    /**
     * When defining a class Foo with an abstract method bar(), you can do:
     * Foo.prototype.bar = abstractMethod
     *
     * Now if a subclass of Foo fails to override bar(), an error will be thrown
     * when bar() is invoked.
     *
     * @type {!Function}
     * @throws {Error} when invoked to indicate the method should be overridden.
     */
    function abstractMethod() {
      throw Error('Unimplemented abstract method');
    }

    /**
     * Disables Metal.js's compatibility mode.
     */
    function disableCompatibilityMode() {
      compatibilityModeData_ = undefined;
    }

    /**
     * Enables Metal.js's compatibility mode with the following features from rc
     * and 1.x versions:
     *     - Using "key" to reference component instances. In the current version
     *       this should be done via "ref" instead. This allows old code still
     *       using "key" to keep working like before. NOTE: this may cause
     *       problems, since "key" is meant to be used differently. Only use this
     *       if it's not possible to upgrade the code to use "ref" instead.
     * @param {Object=} data Optional object with data to specify more
     *     details, such as:
     *         - renderers {Array} the template renderers that should be in
     *           compatibility mode, either their constructors or strings
     *           representing them (e.g. 'soy' or 'jsx'). By default, all the ones
     *           that extend from IncrementalDomRenderer.
     * @type {Object}
     */
    function enableCompatibilityMode() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      compatibilityModeData_ = data;
    }

    /**
     * Returns the data used for compatibility mode, or nothing if it hasn't been
     * enabled.
     * @return {Object}
     */
    function getCompatibilityModeData() {
      // Compatibility mode can be set via the __METAL_COMPATIBILITY__ global var.
      if (compatibilityModeData_ === undefined) {
        if (typeof window !== 'undefined' && window.__METAL_COMPATIBILITY__) {
          enableCompatibilityMode(window.__METAL_COMPATIBILITY__);
        }
      }
      return compatibilityModeData_;
    }

    /**
     * Returns the first argument if it's truthy, or the second otherwise.
     * @param {*} a
     * @param {*} b
     * @return {*}
     * @protected
     */
    function getFirstTruthy_(a, b) {
      return a || b;
    }

    /**
     * Gets the name of the given function. If the current browser doesn't
     * support the `name` property, like IE11, this will calculate it from the function's
     * content string.
     * @param {!function()} fn
     * @return {string}
     */
    function getFunctionName(fn) {
      if (!fn.name) {
        var str = fn.toString();
        fn.name = str.substring(9, str.indexOf('('));
      }
      return fn.name;
    }

    /**
     * Gets the value of a static property in the given class. The value will be
     * inherited from ancestors as expected, unless a custom merge function is given,
     * which can change how the super classes' value for that property will be merged
     * together.
     * The final merged value will be stored in another property, so that it won't
     * be recalculated even if this function is called multiple times.
     * @param {!function()} ctor Class constructor.
     * @param {string} propertyName Property name to be merged.
     * @param {function(*, *):*=} mergeFn Function that receives the merged
     *     value of the property so far and the next value to be merged to it.
     *     Should return these two merged together. If not passed the final property
     *     will be the first truthy value among ancestors.
     * @return {Object}
     */
    function getStaticProperty(ctor, propertyName) {
      var mergeFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getFirstTruthy_;

      var mergedName = propertyName + '_MERGED';
      if (!ctor.hasOwnProperty(mergedName)) {
        // eslint-disable-next-line
        var merged = ctor.hasOwnProperty(propertyName) ? ctor[propertyName] : null;
        if (ctor.__proto__ && !ctor.__proto__.isPrototypeOf(Function)) {
          merged = mergeFn(merged, getStaticProperty(ctor.__proto__, propertyName, mergeFn));
        }
        ctor[mergedName] = merged;
      }
      return ctor[mergedName];
    }

    /**
     * Gets an unique id. If `object` argument is passed, the object is
     * mutated with an unique id. Consecutive calls with the same object
     * reference won't mutate the object again, instead the current object uid
     * returns. See {@link UID_PROPERTY}.
     * @param {Object=} object Optional object to be mutated with the uid. If
     *     not specified this method only returns the uid.
     * @param {boolean=} noInheritance Optional flag indicating if this
     *     object's uid property can be inherited from parents or not.
     * @throws {Error} when invoked to indicate the method should be overridden.
     * @return {number}
     */
    function getUid(object, noInheritance) {
      if (object) {
        var id = object[UID_PROPERTY];
        if (noInheritance && !object.hasOwnProperty(UID_PROPERTY)) {
          id = null;
        }
        return id || (object[UID_PROPERTY] = uniqueIdCounter_++);
      }
      return uniqueIdCounter_++;
    }

    /**
     * The identity function. Returns its first argument.
     * @param {*=} returnValue The single value that will be returned.
     * @return {?} The first argument.
     */
    function identityFunction(returnValue) {
      return returnValue;
    }

    /**
     * Returns true if the specified value is a boolean.
     * @param {?} val Variable to test.
     * @return {boolean} Whether variable is boolean.
     */
    function isBoolean(val) {
      return typeof val === 'boolean';
    }

    /**
     * Returns true if the specified value is not undefined.
     * @param {?} val Variable to test.
     * @return {boolean} Whether variable is defined.
     */
    function isDef(val) {
      return val !== undefined;
    }

    /**
     * Returns true if value is not undefined or null.
     * @param {*} val
     * @return {boolean}
     */
    function isDefAndNotNull(val) {
      return isDef(val) && !isNull(val);
    }

    /**
     * Returns true if value is a document.
     * @param {*} val
     * @return {boolean}
     */
    function isDocument(val) {
      return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 9;
    }

    /**
     * Returns true if value is a document-fragment.
     * @param {*} val
     * @return {boolean}
     */
    function isDocumentFragment(val) {
      return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 11;
    }

    /**
     * Returns true if value is a dom element.
     * @param {*} val
     * @return {boolean}
     */
    function isElement(val) {
      return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 1;
    }

    /**
     * Returns true if the specified value is a function.
     * @param {?} val Variable to test.
     * @return {boolean} Whether variable is a function.
     */
    function isFunction(val) {
      return typeof val === 'function';
    }

    /**
     * Returns true if value is null.
     * @param {*} val
     * @return {boolean}
     */
    function isNull(val) {
      return val === null;
    }

    /**
     * Returns true if the specified value is a number.
     * @param {?} val Variable to test.
     * @return {boolean} Whether variable is a number.
     */
    function isNumber(val) {
      return typeof val === 'number';
    }

    /**
     * Returns true if value is a window.
     * @param {*} val
     * @return {boolean}
     */
    function isWindow(val) {
      return val !== null && val === val.window;
    }

    /**
     * Returns true if the specified value is an object. This includes arrays
     * and functions.
     * @param {?} val Variable to test.
     * @return {boolean} Whether variable is an object.
     */
    function isObject(val) {
      var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
      return type === 'object' && val !== null || type === 'function';
    }

    /**
     * Returns true if value is a Promise.
     * @param {*} val
     * @return {boolean}
     */
    function isPromise(val) {
      return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && typeof val.then === 'function';
    }

    /**
     * Returns true if value is a string.
     * @param {*} val
     * @return {boolean}
     */
    function isString(val) {
      return typeof val === 'string' || val instanceof String;
    }

    /**
     * Sets to true if running inside Node.js environment with extra check for
     * `process.browser` to skip Karma runner environment. Karma environment has
     * `process` defined even though it runs on the browser.
     * @param {?Object} options Contains `checkEnv` property which if true, checks
     * the NODE_ENV variable. If NODE_ENV equals 'test', the function returns false.
     * @return {boolean}
     */
    function isServerSide() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { checkEnv: true };

      var serverSide = typeof process !== 'undefined' && !process.browser;
      if (serverSide && options.checkEnv) {
        serverSide = typeof process.env !== 'undefined' && true;
      }
      return serverSide;
    }

    /**
     * Null function used for default values of callbacks, etc.
     * @return {void} Nothing.
     */
    function nullFunction() {}
    //# sourceMappingURL=coreNamed.js.map
  }
});
//# sourceMappingURL=coreNamed.js.map
'use strict';

// This file exists just for backwards compatibility, making sure that old
// default imports for this file still work. It's best to use the named exports
// for each function instead though, since that allows bundlers like Rollup to
// reduce the bundle size by removing unused code.

Liferay.Loader.define('frontend-js-metal-web$metal@2.16.8/lib/core', ['module', 'exports', 'require', './coreNamed'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.core = undefined;

    var _coreNamed = require('./coreNamed');

    Object.keys(_coreNamed).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _coreNamed[key];
        }
      });
    });

    var core = _interopRequireWildcard(_coreNamed);

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
          }
        }newObj.default = obj;return newObj;
      }
    }

    exports.default = core;
    exports.core = core;
    //# sourceMappingURL=core.js.map
  }
});
//# sourceMappingURL=core.js.map
'use strict';

/**
 * Set of utilities for array operations
 */

Liferay.Loader.define("frontend-js-metal-web$metal@2.16.8/lib/array/array", ['module', 'exports', 'require'], function (module, exports, require) {
	var define = undefined;
	var global = window;
	{
		Object.defineProperty(exports, "__esModule", {
			value: true
		});

		var _createClass = function () {
			function defineProperties(target, props) {
				for (var i = 0; i < props.length; i++) {
					var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
				}
			}return function (Constructor, protoProps, staticProps) {
				if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
			};
		}();

		function _classCallCheck(instance, Constructor) {
			if (!(instance instanceof Constructor)) {
				throw new TypeError("Cannot call a class as a function");
			}
		}

		var array = function () {
			function array() {
				_classCallCheck(this, array);
			}

			_createClass(array, null, [{
				key: 'equal',

				/**
     * Checks if the given arrays have the same content.
     * @param {!Array<*>} arr1
     * @param {!Array<*>} arr2
     * @return {boolean}
     */
				value: function equal(arr1, arr2) {
					if (arr1 === arr2) {
						return true;
					}
					if (arr1.length !== arr2.length) {
						return false;
					}
					for (var i = 0; i < arr1.length; i++) {
						if (arr1[i] !== arr2[i]) {
							return false;
						}
					}
					return true;
				}

				/**
     * Returns the first value in the given array that isn't undefined.
     * @param {!Array} arr
     * @return {*}
     */

			}, {
				key: 'firstDefinedValue',
				value: function firstDefinedValue(arr) {
					for (var i = 0; i < arr.length; i++) {
						if (arr[i] !== undefined) {
							return arr[i];
						}
					}
				}

				/**
     * Transforms the input nested array to become flat.
     * @param {Array.<*|Array.<*>>} arr Nested array to flatten.
     * @param {Array.<*>=} output Optional output array.
     * @return {Array.<*>} Flat array.
     */

			}, {
				key: 'flatten',
				value: function flatten(arr) {
					var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

					for (var i = 0; i < arr.length; i++) {
						if (Array.isArray(arr[i])) {
							array.flatten(arr[i], output);
						} else {
							output.push(arr[i]);
						}
					}
					return output;
				}

				/**
     * Removes the first occurrence of a particular value from an array.
     * @param {Array.<T>} arr Array from which to remove value.
     * @param {T} obj Object to remove.
     * @return {boolean} True if an element was removed.
     * @template T
     */

			}, {
				key: 'remove',
				value: function remove(arr, obj) {
					var i = arr.indexOf(obj);
					var rv = void 0;
					if (rv = i >= 0) {
						array.removeAt(arr, i);
					}
					return rv;
				}

				/**
     * Removes from an array the element at index i
     * @param {Array} arr Array or array like object from which to remove value.
     * @param {number} i The index to remove.
     * @return {boolean} True if an element was removed.
     */

			}, {
				key: 'removeAt',
				value: function removeAt(arr, i) {
					return Array.prototype.splice.call(arr, i, 1).length === 1;
				}

				/**
     * Slices the given array, just like Array.prototype.slice, but this
     * is faster and working on all array-like objects (like arguments).
     * @param {!Object} arr Array-like object to slice.
     * @param {number} start The index that should start the slice.
     * @param {number=} end The index where the slice should end, not
     *   included in the final array. If not given, all elements after the
     *   start index will be included.
     * @return {!Array}
     */

			}, {
				key: 'slice',
				value: function slice(arr, start) {
					var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;

					var sliced = [];
					for (var i = start; i < end; i++) {
						sliced.push(arr[i]);
					}
					return sliced;
				}
			}]);

			return array;
		}();

		exports.default = array;
		//# sourceMappingURL=array.js.map
	}
});
//# sourceMappingURL=array.js.map
/* !
 * Polyfill from Google's Closure Library.
 * Copyright 2013 The Closure Library Authors. All Rights Reserved.
 */

'use strict';

Liferay.Loader.define('frontend-js-metal-web$metal@2.16.8/lib/async/async', ['module', 'exports', 'require', '../coreNamed'], function (module, exports, require) {
	var define = undefined;
	var global = window;
	{
		Object.defineProperty(exports, "__esModule", {
			value: true
		});

		var _coreNamed = require('../coreNamed');

		var async = {};

		/**
   * Throw an item without interrupting the current execution context.  For
   * example, if processing a group of items in a loop, sometimes it is useful
   * to report an error while still allowing the rest of the batch to be
   * processed.
   * @param {*} exception
   */
		async.throwException = function (exception) {
			// Each throw needs to be in its own context.
			async.nextTick(function () {
				throw exception;
			});
		};

		/**
   * Fires the provided callback just before the current callstack unwinds, or as
   * soon as possible after the current JS execution context.
   * @param {function(this:THIS)} callback
   * @param {THIS=} context Object to use as the "this value" when calling
   *     the provided function.
   * @template THIS
   */
		async.run = function (callback, context) {
			if (!async.run.workQueueScheduled_) {
				// Nothing is currently scheduled, schedule it now.
				async.nextTick(async.run.processWorkQueue);
				async.run.workQueueScheduled_ = true;
			}

			async.run.workQueue_.push(new async.run.WorkItem_(callback, context));
		};

		/** @private {boolean} */
		async.run.workQueueScheduled_ = false;

		/** @private {!Array.<!async.run.WorkItem_>} */
		async.run.workQueue_ = [];

		/**
   * Run any pending async.run work items. This function is not intended
   * for general use, but for use by entry point handlers to run items ahead of
   * async.nextTick.
   */
		async.run.processWorkQueue = function () {
			// NOTE: additional work queue items may be pushed while processing.
			while (async.run.workQueue_.length) {
				// Don't let the work queue grow indefinitely.
				var workItems = async.run.workQueue_;
				async.run.workQueue_ = [];
				for (var i = 0; i < workItems.length; i++) {
					var workItem = workItems[i];
					try {
						workItem.fn.call(workItem.scope);
					} catch (e) {
						async.throwException(e);
					}
				}
			}

			// There are no more work items, reset the work queue.
			async.run.workQueueScheduled_ = false;
		};

		/**
   * @constructor
   * @final
   * @struct
   * @private
   *
   * @param {function()} fn
   * @param {Object|null|undefined} scope
   */
		async.run.WorkItem_ = function (fn, scope) {
			/** @const */
			this.fn = fn;
			/** @const */
			this.scope = scope;
		};

		/**
   * Fires the provided callbacks as soon as possible after the current JS
   * execution context. setTimeout(…, 0) always takes at least 5ms for legacy
   * reasons.
   * @param {function(this:SCOPE)} callback Callback function to fire as soon as
   *     possible.
   * @param {SCOPE=} context Object in whose scope to call the listener.
   * @template SCOPE
   */
		async.nextTick = function (callback, context) {
			var cb = callback;
			if (context) {
				cb = callback.bind(context);
			}
			cb = async.nextTick.wrapCallback_(cb);
			// Look for and cache the custom fallback version of setImmediate.
			if (!async.nextTick.setImmediate_) {
				if (typeof setImmediate === 'function' && (0, _coreNamed.isServerSide)({ checkEnv: false })) {
					async.nextTick.setImmediate_ = setImmediate;
				} else {
					// eslint-disable-next-line
					async.nextTick.setImmediate_ = async.nextTick.getSetImmediateEmulator_();
				}
			}
			async.nextTick.setImmediate_(cb);
		};

		/**
   * Cache for the setImmediate implementation.
   * @type {function(function())}
   * @private
   */
		async.nextTick.setImmediate_ = null;

		/**
   * Determines the best possible implementation to run a function as soon as
   * the JS event loop is idle.
   * @return {function(function())} The "setImmediate" implementation.
   * @private
   */
		async.nextTick.getSetImmediateEmulator_ = function () {
			// Create a private message channel and use it to postMessage empty messages
			// to ourselves.
			var Channel = void 0;

			// Verify if variable is defined on the current runtime (i.e., node, browser).
			// Can't use typeof enclosed in a function (such as core.isFunction) or an
			// exception will be thrown when the function is called on an environment
			// where the variable is undefined.
			if (typeof MessageChannel === 'function') {
				Channel = MessageChannel;
			}

			// If MessageChannel is not available and we are in a browser, implement
			// an iframe based polyfill in browsers that have postMessage and
			// document.addEventListener. The latter excludes IE8 because it has a
			// synchronous postMessage implementation.
			if (typeof Channel === 'undefined' && typeof window !== 'undefined' && window.postMessage && window.addEventListener) {
				/** @constructor */
				Channel = function Channel() {
					// Make an empty, invisible iframe.
					var iframe = document.createElement('iframe');
					iframe.style.display = 'none';
					iframe.src = '';
					iframe.title = '';
					document.documentElement.appendChild(iframe);
					var win = iframe.contentWindow;
					var doc = win.document;
					doc.open();
					doc.write('');
					doc.close();
					var message = 'callImmediate' + Math.random();
					var origin = win.location.protocol + '//' + win.location.host;
					var onmessage = function (e) {
						// Validate origin and message to make sure that this message was
						// intended for us.
						if (e.origin !== origin && e.data !== message) {
							return;
						}
						this.port1.onmessage();
					}.bind(this);
					win.addEventListener('message', onmessage, false);
					this.port1 = {};
					this.port2 = {
						postMessage: function postMessage() {
							win.postMessage(message, origin);
						}
					};
				};
			}
			if (typeof Channel !== 'undefined') {
				var channel = new Channel();
				// Use a fifo linked list to call callbacks in the right order.
				var head = {};
				var tail = head;
				channel.port1.onmessage = function () {
					head = head.next;
					var cb = head.cb;
					head.cb = null;
					cb();
				};
				return function (cb) {
					tail.next = {
						cb: cb
					};
					tail = tail.next;
					channel.port2.postMessage(0);
				};
			}
			// Implementation for IE6-8: Script elements fire an asynchronous
			// onreadystatechange event when inserted into the DOM.
			if (typeof document !== 'undefined' && 'onreadystatechange' in document.createElement('script')) {
				return function (cb) {
					var script = document.createElement('script');
					script.onreadystatechange = function () {
						// Clean up and call the callback.
						script.onreadystatechange = null;
						script.parentNode.removeChild(script);
						script = null;
						cb();
						cb = null;
					};
					document.documentElement.appendChild(script);
				};
			}
			// Fall back to setTimeout with 0. In browsers this creates a delay of 5ms
			// or more.
			return function (cb) {
				setTimeout(cb, 0);
			};
		};

		/**
   * Helper function that is overrided to protect callbacks with entry point
   * monitor if the application monitors entry points.
   * @param {function()} callback Callback function to fire as soon as possible.
   * @return {function()} The wrapped callback.
   * @private
   */
		async.nextTick.wrapCallback_ = function (callback) {
			return callback;
		};

		exports.default = async;
		//# sourceMappingURL=async.js.map
	}
});
//# sourceMappingURL=async.js.map
'use strict';

/**
 * Disposable utility. When inherited provides the `dispose` function to its
 * subclass, which is responsible for disposing of any object references
 * when an instance won't be used anymore. Subclasses should override
 * `disposeInternal` to implement any specific disposing logic.
 * @constructor
 */

Liferay.Loader.define("frontend-js-metal-web$metal@2.16.8/lib/disposable/Disposable", ['module', 'exports', 'require'], function (module, exports, require) {
	var define = undefined;
	var global = window;
	{
		Object.defineProperty(exports, "__esModule", {
			value: true
		});

		var _createClass = function () {
			function defineProperties(target, props) {
				for (var i = 0; i < props.length; i++) {
					var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
				}
			}return function (Constructor, protoProps, staticProps) {
				if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
			};
		}();

		function _classCallCheck(instance, Constructor) {
			if (!(instance instanceof Constructor)) {
				throw new TypeError("Cannot call a class as a function");
			}
		}

		var Disposable = function () {
			/**
    * Disposable constructor
    */
			function Disposable() {
				_classCallCheck(this, Disposable);

				/**
     * Flag indicating if this instance has already been disposed.
     * @type {boolean}
     * @protected
     */
				this.disposed_ = false;
			}

			/**
    * Disposes of this instance's object references. Calls `disposeInternal`.
    */

			_createClass(Disposable, [{
				key: 'dispose',
				value: function dispose() {
					if (!this.disposed_) {
						this.disposeInternal();
						this.disposed_ = true;
					}
				}

				/**
     * Subclasses should override this method to implement any specific
     * disposing logic (like clearing references and calling `dispose` on other
     * disposables).
     */

			}, {
				key: 'disposeInternal',
				value: function disposeInternal() {}

				/**
     * Checks if this instance has already been disposed.
     * @return {boolean}
     */

			}, {
				key: 'isDisposed',
				value: function isDisposed() {
					return this.disposed_;
				}
			}]);

			return Disposable;
		}();

		exports.default = Disposable;
		//# sourceMappingURL=Disposable.js.map
	}
});
//# sourceMappingURL=Disposable.js.map
'use strict';

/**
 * Set of utilities for object operations
 */

Liferay.Loader.define("frontend-js-metal-web$metal@2.16.8/lib/object/object", ['module', 'exports', 'require'], function (module, exports, require) {
	var define = undefined;
	var global = window;
	{
		Object.defineProperty(exports, "__esModule", {
			value: true
		});

		var _createClass = function () {
			function defineProperties(target, props) {
				for (var i = 0; i < props.length; i++) {
					var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
				}
			}return function (Constructor, protoProps, staticProps) {
				if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
			};
		}();

		function _classCallCheck(instance, Constructor) {
			if (!(instance instanceof Constructor)) {
				throw new TypeError("Cannot call a class as a function");
			}
		}

		var object = function () {
			function object() {
				_classCallCheck(this, object);
			}

			_createClass(object, null, [{
				key: 'mixin',

				/**
     * Copies all the members of a source object to a target object.
     * @param {Object} target Target object.
     * @param {...Object} var_args The objects from which values will be copied.
     * @return {Object} Returns the target object reference.
     */
				value: function mixin(target) {
					var key = void 0;
					var source = void 0;

					for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
						args[_key - 1] = arguments[_key];
					}

					for (var i = 0; i < args.length; i++) {
						source = args[i];
						// Possible prototype chain leak, breaks 1 metal-dom and
						// 1 metal-incremental-dom test if guard-for-in rule is addressed
						// eslint-disable-next-line
						for (key in source) {
							target[key] = source[key];
						}
					}
					return target;
				}

				/**
     * Returns an object based on its fully qualified external name.
     * @param {string} name The fully qualified name.
     * @param {object=} scope The object within which to look; default is
     *     <code>window</code>.
     * @return {?} The value (object or primitive) or, if not found, undefined.
     */

			}, {
				key: 'getObjectByName',
				value: function getObjectByName(name) {
					var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;

					var parts = name.split('.');
					return parts.reduce(function (part, key) {
						return part[key];
					}, scope);
				}

				/**
     * Returns a new object with the same keys as the given one, but with
     * their values set to the return values of the specified function.
     * @param {!Object} obj
     * @param {!function(string, *)} fn
     * @return {!Object}
     */

			}, {
				key: 'map',
				value: function map(obj, fn) {
					var mappedObj = {};
					var keys = Object.keys(obj);
					for (var i = 0; i < keys.length; i++) {
						mappedObj[keys[i]] = fn(keys[i], obj[keys[i]]);
					}
					return mappedObj;
				}

				/**
     * Checks if the two given objects are equal. This is done via a shallow
     * check, including only the keys directly contained by the 2 objects.
     * @param {Object} obj1
     * @param {Object} obj2
     * @return {boolean}
     */

			}, {
				key: 'shallowEqual',
				value: function shallowEqual(obj1, obj2) {
					if (obj1 === obj2) {
						return true;
					}

					var keys1 = Object.keys(obj1);
					var keys2 = Object.keys(obj2);
					if (keys1.length !== keys2.length) {
						return false;
					}

					for (var i = 0; i < keys1.length; i++) {
						if (obj1[keys1[i]] !== obj2[keys1[i]]) {
							return false;
						}
					}
					return true;
				}
			}]);

			return object;
		}();

		exports.default = object;
		//# sourceMappingURL=object.js.map
	}
});
//# sourceMappingURL=object.js.map
'use strict';

/**
 * Set of utilities for string operations
 */

Liferay.Loader.define("frontend-js-metal-web$metal@2.16.8/lib/string/string", ['module', 'exports', 'require'], function (module, exports, require) {
	var define = undefined;
	var global = window;
	{
		Object.defineProperty(exports, "__esModule", {
			value: true
		});

		var _createClass = function () {
			function defineProperties(target, props) {
				for (var i = 0; i < props.length; i++) {
					var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
				}
			}return function (Constructor, protoProps, staticProps) {
				if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
			};
		}();

		function _classCallCheck(instance, Constructor) {
			if (!(instance instanceof Constructor)) {
				throw new TypeError("Cannot call a class as a function");
			}
		}

		var string = function () {
			function string() {
				_classCallCheck(this, string);
			}

			_createClass(string, null, [{
				key: 'caseInsensitiveCompare',

				/**
     * Compares the given strings without taking the case into account.
     * @param {string|number} str1
     * @param {string|number} str2
     * @return {number} Either -1, 0 or 1, according to if the first string is
     *     "smaller", equal or "bigger" than the second given string.
     */
				value: function caseInsensitiveCompare(str1, str2) {
					var test1 = String(str1).toLowerCase();
					var test2 = String(str2).toLowerCase();

					if (test1 < test2) {
						return -1;
					} else if (test1 === test2) {
						return 0;
					} else {
						return 1;
					}
				}

				/**
     * Removes the breaking spaces from the left and right of the string and
     * collapses the sequences of breaking spaces in the middle into single spaces.
     * The original and the result strings render the same way in HTML.
     * @param {string} str A string in which to collapse spaces.
     * @return {string} Copy of the string with normalized breaking spaces.
     */

			}, {
				key: 'collapseBreakingSpaces',
				value: function collapseBreakingSpaces(str) {
					return str.replace(/[\t\r\n ]+/g, ' ').replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, '');
				}

				/**
     * Escapes characters in the string that are not safe to use in a RegExp.
     * @param {*} str The string to escape. If not a string, it will be casted
     *     to one.
     * @return {string} A RegExp safe, escaped copy of {@code s}.
     */

			}, {
				key: 'escapeRegex',
				value: function escapeRegex(str) {
					return String(str).replace(/([-()[\]{}+?*.$^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08'); // eslint-disable-line
				}

				/**
     * Returns a string with at least 64-bits of randomness.
     * @return {string} A random string, e.g. sn1s7vb4gcic.
     */

			}, {
				key: 'getRandomString',
				value: function getRandomString() {
					var x = 2147483648;
					return Math.floor(Math.random() * x).toString(36) + Math.abs(Math.floor(Math.random() * x) ^ Date.now()).toString(36);
				}

				/**
     * Calculates the hashcode for a string. The hashcode value is computed by
     * the sum algorithm: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]. A nice
     * property of using 31 prime is that the multiplication can be replaced by
     * a shift and a subtraction for better performance: 31*i == (i<<5)-i.
     * Modern VMs do this sort of optimization automatically.
     * @param {String} val Target string.
     * @return {Number} Returns the string hashcode.
     */

			}, {
				key: 'hashCode',
				value: function hashCode(val) {
					var hash = 0;
					for (var i = 0, len = val.length; i < len; i++) {
						hash = 31 * hash + val.charCodeAt(i);
						hash %= 0x100000000;
					}
					return hash;
				}

				/**
     * Replaces interval into the string with specified value, e.g.
     * `replaceInterval("abcde", 1, 4, "")` returns "ae".
     * @param {string} str The input string.
     * @param {Number} start Start interval position to be replaced.
     * @param {Number} end End interval position to be replaced.
     * @param {string} value The value that replaces the specified interval.
     * @return {string}
     */

			}, {
				key: 'replaceInterval',
				value: function replaceInterval(str, start, end, value) {
					return str.substring(0, start) + value + str.substring(end);
				}
			}]);

			return string;
		}();

		exports.default = string;
		//# sourceMappingURL=string.js.map
	}
});
//# sourceMappingURL=string.js.map
'use strict';

Liferay.Loader.define('frontend-js-metal-web$metal@2.16.8/lib/metal', ['module', 'exports', 'require', './core', './array/array', './async/async', './disposable/Disposable', './object/object', './string/string'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.string = exports.object = exports.Disposable = exports.async = exports.array = undefined;

    var _core = require('./core');

    Object.keys(_core).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _core[key];
        }
      });
    });

    var _core2 = _interopRequireDefault(_core);

    var _array = require('./array/array');

    var _array2 = _interopRequireDefault(_array);

    var _async = require('./async/async');

    var _async2 = _interopRequireDefault(_async);

    var _Disposable = require('./disposable/Disposable');

    var _Disposable2 = _interopRequireDefault(_Disposable);

    var _object = require('./object/object');

    var _object2 = _interopRequireDefault(_object);

    var _string = require('./string/string');

    var _string2 = _interopRequireDefault(_string);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.array = _array2.default;
    exports.async = _async2.default;
    exports.Disposable = _Disposable2.default;
    exports.object = _object2.default;
    exports.string = _string2.default;
    exports.default = _core2.default;
    //# sourceMappingURL=metal.js.map
  }
});
//# sourceMappingURL=metal.js.map
'use strict';

Liferay.Loader.define("frontend-js-metal-web$metal-dom@2.16.8/lib/domData", ['module', 'exports', 'require', 'frontend-js-metal-web$metal'], function (module, exports, require) {
	var define = undefined;
	var global = window;
	{
		Object.defineProperty(exports, "__esModule", {
			value: true
		});

		var _createClass = function () {
			function defineProperties(target, props) {
				for (var i = 0; i < props.length; i++) {
					var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
				}
			}return function (Constructor, protoProps, staticProps) {
				if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
			};
		}();

		var _metal = require("frontend-js-metal-web$metal");

		function _classCallCheck(instance, Constructor) {
			if (!(instance instanceof Constructor)) {
				throw new TypeError("Cannot call a class as a function");
			}
		}

		var METAL_DATA = '__metal_data__';

		/**
   * Set of utilities for dom data operations
   */

		var domData = function () {
			function domData() {
				_classCallCheck(this, domData);
			}

			_createClass(domData, null, [{
				key: 'get',

				/**
     * Gets Metal.js's data for the given element.
     * @param {!Element} element
     * @param {string=} name Optional property from the data to be returned.
     * @param {*=} initialValue Optional value to the set the requested property
     *     to if it doesn't exist yet in the data.
     * @return {!Object}
     */
				value: function get(element, name, initialValue) {
					if (!element[METAL_DATA]) {
						element[METAL_DATA] = {};
					}
					if (!name) {
						return element[METAL_DATA];
					}
					if (!(0, _metal.isDef)(element[METAL_DATA][name]) && (0, _metal.isDef)(initialValue)) {
						element[METAL_DATA][name] = initialValue;
					}
					return element[METAL_DATA][name];
				}

				/**
     * Checks if the given element has data stored in it.
     * @param {!Element} element
     * @return {boolean}
     */

			}, {
				key: 'has',
				value: function has(element) {
					return !!element[METAL_DATA];
				}

				/**
     * Sets Metal.js's data for the given element.
     * @param {!Element} element
     * @param {string=} name Property from the data to be set.
     * @param {*=} value Value to be set on the element.
     * @return {!Object|*}
     */

			}, {
				key: 'set',
				value: function set(element, name, value) {
					if (!element[METAL_DATA]) {
						element[METAL_DATA] = {};
					}
					if (!name || !(0, _metal.isDef)(value)) {
						return element[METAL_DATA];
					}
					element[METAL_DATA][name] = value;
					return element[METAL_DATA][name];
				}
			}]);

			return domData;
		}();

		exports.default = domData;
		//# sourceMappingURL=domData.js.map
	}
});
//# sourceMappingURL=domData.js.map
'use strict';

Liferay.Loader.define("frontend-js-metal-web$metal-events@2.16.8/lib/EventHandle", ['module', 'exports', 'require', 'frontend-js-metal-web$metal'], function (module, exports, require) {
	var define = undefined;
	var global = window;
	{
		Object.defineProperty(exports, "__esModule", {
			value: true
		});

		var _createClass = function () {
			function defineProperties(target, props) {
				for (var i = 0; i < props.length; i++) {
					var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
				}
			}return function (Constructor, protoProps, staticProps) {
				if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
			};
		}();

		var _metal = require("frontend-js-metal-web$metal");

		function _classCallCheck(instance, Constructor) {
			if (!(instance instanceof Constructor)) {
				throw new TypeError("Cannot call a class as a function");
			}
		}

		function _possibleConstructorReturn(self, call) {
			if (!self) {
				throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
			}return call && (typeof call === "object" || typeof call === "function") ? call : self;
		}

		function _inherits(subClass, superClass) {
			if (typeof superClass !== "function" && superClass !== null) {
				throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
			}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
		}

		/**
   * EventHandle utility. Holds information about an event subscription, and
   * allows removing them easily.
   * EventHandle is a Disposable, but it's important to note that the
   * EventEmitter that created it is not the one responsible for disposing it.
   * That responsibility is for the code that holds a reference to it.
   * @extends {Disposable}
   */
		var EventHandle = function (_Disposable) {
			_inherits(EventHandle, _Disposable);

			/**
    * EventHandle constructor
    * @param {!EventEmitter} emitter Emitter the event was subscribed to.
    * @param {string} event The name of the event that was subscribed to.
    * @param {!Function} listener The listener subscribed to the event.
    */
			function EventHandle(emitter, event, listener) {
				_classCallCheck(this, EventHandle);

				/**
     * The EventEmitter instance that the event was subscribed to.
     * @type {EventEmitter}
     * @protected
     */
				var _this = _possibleConstructorReturn(this, (EventHandle.__proto__ || Object.getPrototypeOf(EventHandle)).call(this));

				_this.emitter_ = emitter;

				/**
     * The name of the event that was subscribed to.
     * @type {string}
     * @protected
     */
				_this.event_ = event;

				/**
     * The listener subscribed to the event.
     * @type {Function}
     * @protected
     */
				_this.listener_ = listener;
				return _this;
			}

			/**
    * Disposes of this instance's object references.
    * @override
    */

			_createClass(EventHandle, [{
				key: 'disposeInternal',
				value: function disposeInternal() {
					this.removeListener();
					this.emitter_ = null;
					this.listener_ = null;
				}

				/**
     * Removes the listener subscription from the emitter.
     */

			}, {
				key: 'removeListener',
				value: function removeListener() {
					if (!this.emitter_.isDisposed()) {
						this.emitter_.removeListener(this.event_, this.listener_);
					}
				}
			}]);

			return EventHandle;
		}(_metal.Disposable);

		exports.default = EventHandle;
		//# sourceMappingURL=EventHandle.js.map
	}
});
//# sourceMappingURL=EventHandle.js.map
'use strict';

Liferay.Loader.define("frontend-js-metal-web$metal-events@2.16.8/lib/EventEmitter", ['module', 'exports', 'require', 'frontend-js-metal-web$metal', './EventHandle'], function (module, exports, require) {
	var define = undefined;
	var global = window;
	{
		Object.defineProperty(exports, "__esModule", {
			value: true
		});

		var _createClass = function () {
			function defineProperties(target, props) {
				for (var i = 0; i < props.length; i++) {
					var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
				}
			}return function (Constructor, protoProps, staticProps) {
				if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
			};
		}();

		var _metal = require("frontend-js-metal-web$metal");

		var _EventHandle = require('./EventHandle');

		var _EventHandle2 = _interopRequireDefault(_EventHandle);

		function _interopRequireDefault(obj) {
			return obj && obj.__esModule ? obj : { default: obj };
		}

		function _classCallCheck(instance, Constructor) {
			if (!(instance instanceof Constructor)) {
				throw new TypeError("Cannot call a class as a function");
			}
		}

		function _possibleConstructorReturn(self, call) {
			if (!self) {
				throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
			}return call && (typeof call === "object" || typeof call === "function") ? call : self;
		}

		function _inherits(subClass, superClass) {
			if (typeof superClass !== "function" && superClass !== null) {
				throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
			}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
		}

		var singleArray_ = [0];

		/**
   * EventEmitter utility.
   * @extends {Disposable}
   */

		var EventEmitter = function (_Disposable) {
			_inherits(EventEmitter, _Disposable);

			/**
    * EventEmitter constructor
    */
			function EventEmitter() {
				_classCallCheck(this, EventEmitter);

				/**
     * Holds event listeners scoped by event type.
     * @type {Object<string, !Array<!function()>>}
     * @protected
     */
				var _this = _possibleConstructorReturn(this, (EventEmitter.__proto__ || Object.getPrototypeOf(EventEmitter)).call(this));

				_this.events_ = null;

				/**
     * Handlers that are triggered when an event is listened to.
     * @type {Array}
     */
				_this.listenerHandlers_ = null;

				/**
     * Configuration option which determines if an event facade should be sent
     * as a param of listeners when emitting events. If set to true, the facade
     * will be passed as the first argument of the listener.
     * @type {boolean}
     * @protected
     */
				_this.shouldUseFacade_ = false;
				return _this;
			}

			/**
    * Adds a handler to given holder variable. If the holder doesn't have a
    * value yet, it will receive the handler directly. If the holder is an array,
    * the value will just be added to it. Otherwise, the holder will be set to a
    * new array containing its previous value plus the new handler.
    * @param {*} holder
    * @param {!function()|Object} handler
    * @return {*} The holder's new value.
    * @protected
    */

			_createClass(EventEmitter, [{
				key: 'addHandler_',
				value: function addHandler_(holder, handler) {
					if (!holder) {
						holder = handler;
					} else {
						if (!Array.isArray(holder)) {
							holder = [holder];
						}
						holder.push(handler);
					}
					return holder;
				}

				/**
     * Adds a listener to the end of the listeners array for the specified events.
     * @param {!(Array|string)} event
     * @param {!Function} listener
     * @param {boolean} defaultListener Flag indicating if this listener is a default
     *   action for this event. Default actions are run last, and only if no previous
     *   listener call `preventDefault()` on the received event facade.
     * @return {!EventHandle} Can be used to remove the listener.
     */

			}, {
				key: 'addListener',
				value: function addListener(event, listener, defaultListener) {
					this.validateListener_(listener);

					var events = this.toEventsArray_(event);
					for (var i = 0; i < events.length; i++) {
						this.addSingleListener_(events[i], listener, defaultListener);
					}

					return new _EventHandle2.default(this, event, listener);
				}

				/**
     * Adds a listener to the end of the listeners array for a single event.
     * @param {string} event
     * @param {!Function} listener
     * @param {boolean} defaultListener Flag indicating if this listener is a default
     *   action for this event. Default actions are run last, and only if no previous
     *   listener call `preventDefault()` on the received event facade.
     * @param {Function=} origin The original function that was added as a
     *   listener, if there is any.
     * @protected
     */

			}, {
				key: 'addSingleListener_',
				value: function addSingleListener_(event, listener, defaultListener, origin) {
					this.runListenerHandlers_(event);
					if (defaultListener || origin) {
						listener = {
							default: defaultListener,
							fn: listener,
							origin: origin
						};
					}
					this.events_ = this.events_ || {};
					this.events_[event] = this.addHandler_(this.events_[event], listener);
				}

				/**
     * Builds facade for the given event.
     * @param {string} event
     * @return {Object}
     * @protected
     */

			}, {
				key: 'buildFacade_',
				value: function buildFacade_(event) {
					if (this.getShouldUseFacade()) {
						var facade = {
							preventDefault: function preventDefault() {
								facade.preventedDefault = true;
							},
							target: this,
							type: event
						};
						return facade;
					}
				}

				/**
     * Disposes of this instance's object references.
     * @override
     */

			}, {
				key: 'disposeInternal',
				value: function disposeInternal() {
					this.events_ = null;
				}

				/**
     * Execute each of the listeners in order with the supplied arguments.
     * @param {string} event
     * @param {*} opt_args [arg1], [arg2], [...]
     * @return {boolean} Returns true if event had listeners, false otherwise.
     */

			}, {
				key: 'emit',
				value: function emit(event) {
					var listeners = this.getRawListeners_(event);
					if (listeners.length === 0) {
						return false;
					}

					var args = _metal.array.slice(arguments, 1); // eslint-disable-line
					this.runListeners_(listeners, args, this.buildFacade_(event));
					return true;
				}

				/**
     * Gets the listener objects for the given event, if there are any.
     * @param {string} event
     * @return {!Array}
     * @protected
     */

			}, {
				key: 'getRawListeners_',
				value: function getRawListeners_(event) {
					var directListeners = toArray(this.events_ && this.events_[event]);
					return directListeners.concat(toArray(this.events_ && this.events_['*']));
				}

				/**
     * Gets the configuration option which determines if an event facade should
     * be sent as a param of listeners when emitting events. If set to true, the
     * facade will be passed as the first argument of the listener.
     * @return {boolean}
     */

			}, {
				key: 'getShouldUseFacade',
				value: function getShouldUseFacade() {
					return this.shouldUseFacade_;
				}

				/**
     * Returns an array of listeners for the specified event.
     * @param {string} event
     * @return {Array} Array of listeners.
     */

			}, {
				key: 'listeners',
				value: function listeners(event) {
					return this.getRawListeners_(event).map(function (listener) {
						return listener.fn ? listener.fn : listener;
					});
				}

				/**
     * Adds a listener that will be invoked a fixed number of times for the
     * events. After each event is triggered the specified amount of times, the
     * listener is removed for it.
     * @param {!(Array|string)} event
     * @param {number} amount The amount of times this event should be listened
     * to.
     * @param {!Function} listener
     * @return {!EventHandle} Can be used to remove the listener.
     */

			}, {
				key: 'many',
				value: function many(event, amount, listener) {
					var events = this.toEventsArray_(event);
					for (var i = 0; i < events.length; i++) {
						this.many_(events[i], amount, listener);
					}

					return new _EventHandle2.default(this, event, listener);
				}

				/**
     * Adds a listener that will be invoked a fixed number of times for a single
     * event. After the event is triggered the specified amount of times, the
     * listener is removed.
     * @param {string} event
     * @param {number} amount The amount of times this event should be listened
     * to.
     * @param {!Function} listener
     * @protected
     */

			}, {
				key: 'many_',
				value: function many_(event, amount, listener) {
					var self = this;

					if (amount <= 0) {
						return;
					}

					/**
      *
      */
					function handlerInternal() {
						if (--amount === 0) {
							self.removeListener(event, handlerInternal);
						}
						listener.apply(self, arguments); // eslint-disable-line
					}

					self.addSingleListener_(event, handlerInternal, false, listener);
				}

				/**
     * Checks if a listener object matches the given listener function. To match,
     * it needs to either point to that listener or have it as its origin.
     * @param {!Object} listenerObj
     * @param {!Function} listener
     * @return {boolean}
     * @protected
     */

			}, {
				key: 'matchesListener_',
				value: function matchesListener_(listenerObj, listener) {
					var fn = listenerObj.fn || listenerObj;
					return fn === listener || listenerObj.origin && listenerObj.origin === listener // eslint-disable-line
					;
				}

				/**
     * Removes a listener for the specified events.
     * Caution: changes array indices in the listener array behind the listener.
     * @param {!(Array|string)} event
     * @param {!Function} listener
     * @return {!Object} Returns emitter, so calls can be chained.
     */

			}, {
				key: 'off',
				value: function off(event, listener) {
					this.validateListener_(listener);
					if (!this.events_) {
						return this;
					}

					var events = this.toEventsArray_(event);
					for (var i = 0; i < events.length; i++) {
						this.events_[events[i]] = this.removeMatchingListenerObjs_(toArray(this.events_[events[i]]), listener);
					}

					return this;
				}

				/**
     * Adds a listener to the end of the listeners array for the specified events.
     * @param {!(Array|string)} events
     * @param {!Function} listener
     * @return {!EventHandle} Can be used to remove the listener.
     */

			}, {
				key: 'on',
				value: function on() {
					return this.addListener.apply(this, arguments); // eslint-disable-line
				}

				/**
     * Adds handler that gets triggered when an event is listened to on this
     * instance.
     * @param {!function()} handler
     */

			}, {
				key: 'onListener',
				value: function onListener(handler) {
					this.listenerHandlers_ = this.addHandler_(this.listenerHandlers_, handler); // eslint-disable-line
				}

				/**
     * Adds a one time listener for the events. This listener is invoked only the
     * next time each event is fired, after which it is removed.
     * @param {!(Array|string)} events
     * @param {!Function} listener
     * @return {!EventHandle} Can be used to remove the listener.
     */

			}, {
				key: 'once',
				value: function once(events, listener) {
					return this.many(events, 1, listener);
				}

				/**
     * Removes all listeners, or those of the specified events. It's not a good
     * idea to remove listeners that were added elsewhere in the code,
     * especially when it's on an emitter that you didn't create.
     * @param {(Array|string)=} event
     * @return {!Object} Returns emitter, so calls can be chained.
     */

			}, {
				key: 'removeAllListeners',
				value: function removeAllListeners(event) {
					if (this.events_) {
						if (event) {
							var events = this.toEventsArray_(event);
							for (var i = 0; i < events.length; i++) {
								this.events_[events[i]] = null;
							}
						} else {
							this.events_ = null;
						}
					}
					return this;
				}

				/**
     * Removes all listener objects from the given array that match the given
     * listener function.
     * @param {Array.<Object>} listenerObjs
     * @param {!Function} listener
     * @return {Array.<Object>|Object} The new listeners array for this event.
     * @protected
     */

			}, {
				key: 'removeMatchingListenerObjs_',
				value: function removeMatchingListenerObjs_(listenerObjs, listener) {
					var finalListeners = [];
					for (var i = 0; i < listenerObjs.length; i++) {
						if (!this.matchesListener_(listenerObjs[i], listener)) {
							finalListeners.push(listenerObjs[i]);
						}
					}
					return finalListeners.length > 0 ? finalListeners : null;
				}

				/**
     * Removes a listener for the specified events.
     * Caution: changes array indices in the listener array behind the listener.
     * @param {!(Array|string)} events
     * @param {!Function} listener
     * @return {!Object} Returns emitter, so calls can be chained.
     */

			}, {
				key: 'removeListener',
				value: function removeListener() {
					return this.off.apply(this, arguments); // eslint-disable-line
				}

				/**
     * Runs the handlers when an event is listened to.
     * @param {string} event
     * @protected
     */

			}, {
				key: 'runListenerHandlers_',
				value: function runListenerHandlers_(event) {
					var handlers = this.listenerHandlers_;
					if (handlers) {
						handlers = toArray(handlers);
						for (var i = 0; i < handlers.length; i++) {
							handlers[i](event);
						}
					}
				}

				/**
     * Runs the given listeners.
     * @param {!Array} listeners
     * @param {!Array} args
     * @param {Object} facade
     * @protected
     */

			}, {
				key: 'runListeners_',
				value: function runListeners_(listeners, args, facade) {
					if (facade) {
						args.push(facade);
					}

					var defaultListeners = [];
					for (var i = 0; i < listeners.length; i++) {
						var listener = listeners[i].fn || listeners[i];
						if (listeners[i].default) {
							defaultListeners.push(listener);
						} else {
							listener.apply(this, args);
						}
					}
					if (!facade || !facade.preventedDefault) {
						for (var j = 0; j < defaultListeners.length; j++) {
							defaultListeners[j].apply(this, args);
						}
					}
				}

				/**
     * Sets the configuration option which determines if an event facade should
     * be sent as a param of listeners when emitting events. If set to true, the
     * facade will be passed as the first argument of the listener.
     * @param {boolean} shouldUseFacade
     * @return {!Object} Returns emitter, so calls can be chained.
     */

			}, {
				key: 'setShouldUseFacade',
				value: function setShouldUseFacade(shouldUseFacade) {
					this.shouldUseFacade_ = shouldUseFacade;
					return this;
				}

				/**
     * Converts the parameter to an array if only one event is given. Reuses the
     * same array each time this conversion is done, to avoid using more memory
     * than necessary.
     * @param  {!(Array|string)} events
     * @return {!Array}
     * @protected
     */

			}, {
				key: 'toEventsArray_',
				value: function toEventsArray_(events) {
					if ((0, _metal.isString)(events)) {
						singleArray_[0] = events;
						events = singleArray_;
					}
					return events;
				}

				/**
     * Checks if the given listener is valid, throwing an exception when it's not.
     * @param  {*} listener
     * @protected
     */

			}, {
				key: 'validateListener_',
				value: function validateListener_(listener) {
					if (!(0, _metal.isFunction)(listener)) {
						throw new TypeError('Listener must be a function');
					}
				}
			}]);

			return EventEmitter;
		}(_metal.Disposable);

		/**
   * Converts to an array
   * @param {Object} val
   * @return {Array}
   */

		function toArray(val) {
			val = val || [];
			return Array.isArray(val) ? val : [val];
		}

		exports.default = EventEmitter;
		//# sourceMappingURL=EventEmitter.js.map
	}
});
//# sourceMappingURL=EventEmitter.js.map
'use strict';

Liferay.Loader.define("frontend-js-metal-web$metal-events@2.16.8/lib/EventEmitterProxy", ['module', 'exports', 'require', 'frontend-js-metal-web$metal'], function (module, exports, require) {
	var define = undefined;
	var global = window;
	{
		Object.defineProperty(exports, "__esModule", {
			value: true
		});

		var _createClass = function () {
			function defineProperties(target, props) {
				for (var i = 0; i < props.length; i++) {
					var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
				}
			}return function (Constructor, protoProps, staticProps) {
				if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
			};
		}();

		var _metal = require("frontend-js-metal-web$metal");

		function _classCallCheck(instance, Constructor) {
			if (!(instance instanceof Constructor)) {
				throw new TypeError("Cannot call a class as a function");
			}
		}

		function _possibleConstructorReturn(self, call) {
			if (!self) {
				throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
			}return call && (typeof call === "object" || typeof call === "function") ? call : self;
		}

		function _inherits(subClass, superClass) {
			if (typeof superClass !== "function" && superClass !== null) {
				throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
			}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
		}

		/**
   * EventEmitterProxy utility. It's responsible for linking two EventEmitter
   * instances together, emitting events from the first emitter through the
   * second one. That means that listening to a supported event on the target
   * emitter will mean listening to it on the origin emitter as well.
   * @extends {Disposable}
   */
		var EventEmitterProxy = function (_Disposable) {
			_inherits(EventEmitterProxy, _Disposable);

			/**
    * @param {EventEmitter} originEmitter Events originated on this emitter
    * will be fired for the target emitter's listeners as well.
    * @param {EventEmitter} targetEmitter Event listeners attached to this emitter
    * will also be triggered when the event is fired by the origin emitter.
    * @param {Object} blacklist Optional blacklist of events that should not be
    * proxied.
    * @param {Object} whitelist
    */
			function EventEmitterProxy(originEmitter, targetEmitter, blacklist, whitelist) {
				_classCallCheck(this, EventEmitterProxy);

				/**
     * Map of events that should not be proxied.
     * @type {Object}
     * @protected
     */
				var _this = _possibleConstructorReturn(this, (EventEmitterProxy.__proto__ || Object.getPrototypeOf(EventEmitterProxy)).call(this));

				_this.blacklist_ = blacklist;

				/**
     * The origin emitter. This emitter's events will be proxied through the
     * target emitter.
     * @type {EventEmitter}
     * @protected
     */
				_this.originEmitter_ = originEmitter;

				/**
     * A list of events that are pending to be listened by an actual origin
     * emitter. Events are stored here when the origin doesn't exist, so they
     * can be set on a new origin when one is set.
     * @type {Array}
     * @protected
     */
				_this.pendingEvents_ = null;

				/**
     * Holds a map of events from the origin emitter that are already being proxied.
     * @type {Object<string, !EventHandle>}
     * @protected
     */
				_this.proxiedEvents_ = null;

				/**
     * The target emitter. This emitter will emit all events that come from
     * the origin emitter.
     * @type {EventEmitter}
     * @protected
     */
				_this.targetEmitter_ = targetEmitter;

				/**
     * Map of events that should be proxied. If whitelist is set blacklist is ignored.
     * @type {Object}
     * @protected
     */
				_this.whitelist_ = whitelist;

				_this.startProxy_();
				return _this;
			}

			/**
    * Adds the given listener for the given event.
    * @param {string} event
    * @param {!function()} listener
    * @return {!EventHandle} The listened event's handle.
    * @protected
    */

			_createClass(EventEmitterProxy, [{
				key: 'addListener_',
				value: function addListener_(event, listener) {
					return this.originEmitter_.on(event, listener);
				}

				/**
     * @inheritDoc
     */

			}, {
				key: 'disposeInternal',
				value: function disposeInternal() {
					this.removeListeners_();
					this.proxiedEvents_ = null;
					this.originEmitter_ = null;
					this.targetEmitter_ = null;
				}

				/**
     * Emits the specified event type on the target emitter.
     * @protected
     */

			}, {
				key: 'emitOnTarget_',
				value: function emitOnTarget_() {
					var _targetEmitter_;

					(_targetEmitter_ = this.targetEmitter_).emit.apply(_targetEmitter_, arguments);
				}

				/**
     * Proxies the given event from the origin to the target emitter.
     * @param {string} event
     */

			}, {
				key: 'proxyEvent',
				value: function proxyEvent(event) {
					if (this.shouldProxyEvent_(event)) {
						this.tryToAddListener_(event);
					}
				}

				/**
     * Removes the proxy listener for all events.
     * @protected
     */

			}, {
				key: 'removeListeners_',
				value: function removeListeners_() {
					if (this.proxiedEvents_) {
						var events = Object.keys(this.proxiedEvents_);
						for (var i = 0; i < events.length; i++) {
							this.proxiedEvents_[events[i]].removeListener();
						}
						this.proxiedEvents_ = null;
					}
					this.pendingEvents_ = null;
				}

				/**
     * Changes the origin emitter. This automatically detaches any events that
     * were already being proxied from the previous emitter, and starts proxying
     * them on the new emitter instead.
     * @param {!EventEmitter} originEmitter
     */

			}, {
				key: 'setOriginEmitter',
				value: function setOriginEmitter(originEmitter) {
					var _this2 = this;

					var events = this.originEmitter_ && this.proxiedEvents_ ? Object.keys(this.proxiedEvents_) : this.pendingEvents_;
					this.originEmitter_ = originEmitter;
					if (events) {
						this.removeListeners_();
						events.forEach(function (event) {
							return _this2.proxyEvent(event);
						});
					}
				}

				/**
     * Checks if the given event should be proxied.
     * @param {string} event
     * @return {boolean}
     * @protected
     */

			}, {
				key: 'shouldProxyEvent_',
				value: function shouldProxyEvent_(event) {
					if (this.whitelist_ && !this.whitelist_[event]) {
						return false;
					}
					if (this.blacklist_ && this.blacklist_[event]) {
						return false;
					}
					return !this.proxiedEvents_ || !this.proxiedEvents_[event];
				}

				/**
     * Starts proxying all events from the origin to the target emitter.
     * @protected
     */

			}, {
				key: 'startProxy_',
				value: function startProxy_() {
					this.targetEmitter_.onListener(this.proxyEvent.bind(this));
				}

				/**
     * Adds a listener to the origin emitter, if it exists. Otherwise, stores
     * the pending listener so it can be used on a future origin emitter.
     * @param {string} event
     * @protected
     */

			}, {
				key: 'tryToAddListener_',
				value: function tryToAddListener_(event) {
					if (this.originEmitter_) {
						this.proxiedEvents_ = this.proxiedEvents_ || {};
						this.proxiedEvents_[event] = this.addListener_(event, this.emitOnTarget_.bind(this, event));
					} else {
						this.pendingEvents_ = this.pendingEvents_ || [];
						this.pendingEvents_.push(event);
					}
				}
			}]);

			return EventEmitterProxy;
		}(_metal.Disposable);

		exports.default = EventEmitterProxy;
		//# sourceMappingURL=EventEmitterProxy.js.map
	}
});
//# sourceMappingURL=EventEmitterProxy.js.map
'use strict';

Liferay.Loader.define("frontend-js-metal-web$metal-events@2.16.8/lib/EventHandler", ['module', 'exports', 'require', 'frontend-js-metal-web$metal'], function (module, exports, require) {
	var define = undefined;
	var global = window;
	{
		Object.defineProperty(exports, "__esModule", {
			value: true
		});

		var _createClass = function () {
			function defineProperties(target, props) {
				for (var i = 0; i < props.length; i++) {
					var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
				}
			}return function (Constructor, protoProps, staticProps) {
				if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
			};
		}();

		var _metal = require("frontend-js-metal-web$metal");

		function _classCallCheck(instance, Constructor) {
			if (!(instance instanceof Constructor)) {
				throw new TypeError("Cannot call a class as a function");
			}
		}

		function _possibleConstructorReturn(self, call) {
			if (!self) {
				throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
			}return call && (typeof call === "object" || typeof call === "function") ? call : self;
		}

		function _inherits(subClass, superClass) {
			if (typeof superClass !== "function" && superClass !== null) {
				throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
			}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
		}

		/**
   * EventHandler utility. It's useful for easily removing a group of
   * listeners from different EventEmitter instances.
   * @extends {Disposable}
   */
		var EventHandler = function (_Disposable) {
			_inherits(EventHandler, _Disposable);

			/**
    * EventHandler constructor
    */
			function EventHandler() {
				_classCallCheck(this, EventHandler);

				/**
     * An array that holds the added event handles, so the listeners can be
     * removed later.
     * @type {Array.<EventHandle>}
     * @protected
     */
				var _this = _possibleConstructorReturn(this, (EventHandler.__proto__ || Object.getPrototypeOf(EventHandler)).call(this));

				_this.eventHandles_ = [];
				return _this;
			}

			/**
    * Adds event handles to be removed later through the `removeAllListeners`
    * method.
    * @param {...(!EventHandle)} var_args
    */

			_createClass(EventHandler, [{
				key: 'add',
				value: function add() {
					for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
						args[_key] = arguments[_key];
					}

					for (var i = 0; i < arguments.length; i++) {
						this.eventHandles_.push(args[i]);
					}
				}

				/**
     * Disposes of this instance's object references.
     * @override
     */

			}, {
				key: 'disposeInternal',
				value: function disposeInternal() {
					this.eventHandles_ = null;
				}

				/**
     * Removes all listeners that have been added through the `add` method.
     */

			}, {
				key: 'removeAllListeners',
				value: function removeAllListeners() {
					for (var i = 0; i < this.eventHandles_.length; i++) {
						this.eventHandles_[i].removeListener();
					}

					this.eventHandles_ = [];
				}
			}]);

			return EventHandler;
		}(_metal.Disposable);

		exports.default = EventHandler;
		//# sourceMappingURL=EventHandler.js.map
	}
});
//# sourceMappingURL=EventHandler.js.map
'use strict';

Liferay.Loader.define('frontend-js-metal-web$metal-events@2.16.8/lib/events', ['module', 'exports', 'require', './EventEmitter', './EventEmitterProxy', './EventHandle', './EventHandler'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.EventHandler = exports.EventHandle = exports.EventEmitterProxy = exports.EventEmitter = undefined;

    var _EventEmitter = require('./EventEmitter');

    var _EventEmitter2 = _interopRequireDefault(_EventEmitter);

    var _EventEmitterProxy = require('./EventEmitterProxy');

    var _EventEmitterProxy2 = _interopRequireDefault(_EventEmitterProxy);

    var _EventHandle = require('./EventHandle');

    var _EventHandle2 = _interopRequireDefault(_EventHandle);

    var _EventHandler = require('./EventHandler');

    var _EventHandler2 = _interopRequireDefault(_EventHandler);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = _EventEmitter2.default;
    exports.EventEmitter = _EventEmitter2.default;
    exports.EventEmitterProxy = _EventEmitterProxy2.default;
    exports.EventHandle = _EventHandle2.default;
    exports.EventHandler = _EventHandler2.default;
    //# sourceMappingURL=events.js.map
  }
});
//# sourceMappingURL=events.js.map
'use strict';

Liferay.Loader.define("frontend-js-metal-web$metal-dom@2.16.8/lib/DomDelegatedEventHandle", ['module', 'exports', 'require', 'frontend-js-metal-web$metal', './domData', 'frontend-js-metal-web$metal-events'], function (module, exports, require) {
	var define = undefined;
	var global = window;
	{
		Object.defineProperty(exports, "__esModule", {
			value: true
		});

		var _createClass = function () {
			function defineProperties(target, props) {
				for (var i = 0; i < props.length; i++) {
					var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
				}
			}return function (Constructor, protoProps, staticProps) {
				if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
			};
		}();

		var _metal = require("frontend-js-metal-web$metal");

		var _domData = require('./domData');

		var _domData2 = _interopRequireDefault(_domData);

		var _metalEvents = require("frontend-js-metal-web$metal-events");

		function _interopRequireDefault(obj) {
			return obj && obj.__esModule ? obj : { default: obj };
		}

		function _classCallCheck(instance, Constructor) {
			if (!(instance instanceof Constructor)) {
				throw new TypeError("Cannot call a class as a function");
			}
		}

		function _possibleConstructorReturn(self, call) {
			if (!self) {
				throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
			}return call && (typeof call === "object" || typeof call === "function") ? call : self;
		}

		function _inherits(subClass, superClass) {
			if (typeof superClass !== "function" && superClass !== null) {
				throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
			}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
		}

		/**
   * This is a special EventHandle, that is responsible for dom delegated events
   * (only the ones that receive a target element, not a selector string).
   * @extends {EventHandle}
   */
		var DomDelegatedEventHandle = function (_EventHandle) {
			_inherits(DomDelegatedEventHandle, _EventHandle);

			/**
    * The constructor for `DomDelegatedEventHandle`.
    * @param {!Event} emitter Element the event was subscribed to.
    * @param {string} event The name of the event that was subscribed to.
    * @param {!Function} listener The listener subscribed to the event.
    * @param {string=} selector An optional selector used when delegating
    *     the event.
    * @constructor
    */
			function DomDelegatedEventHandle(emitter, event, listener, selector) {
				_classCallCheck(this, DomDelegatedEventHandle);

				var _this = _possibleConstructorReturn(this, (DomDelegatedEventHandle.__proto__ || Object.getPrototypeOf(DomDelegatedEventHandle)).call(this, emitter, event, listener));

				_this.selector_ = selector;
				return _this;
			}

			/**
    * @inheritDoc
    */

			_createClass(DomDelegatedEventHandle, [{
				key: 'removeListener',
				value: function removeListener() {
					var delegating = _domData2.default.get(this.emitter_, 'delegating', {});
					var listeners = _domData2.default.get(this.emitter_, 'listeners', {});
					var selector = this.selector_;
					var arr = (0, _metal.isString)(selector) ? delegating[this.event_].selectors : listeners;
					var key = (0, _metal.isString)(selector) ? selector : this.event_;

					_metal.array.remove(arr[key] || [], this.listener_);
					if (arr[key] && arr[key].length === 0) {
						delete arr[key];
					}
				}
			}]);

			return DomDelegatedEventHandle;
		}(_metalEvents.EventHandle);

		exports.default = DomDelegatedEventHandle;
		//# sourceMappingURL=DomDelegatedEventHandle.js.map
	}
});
//# sourceMappingURL=DomDelegatedEventHandle.js.map
'use strict';

Liferay.Loader.define("frontend-js-metal-web$metal-dom@2.16.8/lib/DomEventHandle", ['module', 'exports', 'require', 'frontend-js-metal-web$metal-events'], function (module, exports, require) {
	var define = undefined;
	var global = window;
	{
		Object.defineProperty(exports, "__esModule", {
			value: true
		});

		var _createClass = function () {
			function defineProperties(target, props) {
				for (var i = 0; i < props.length; i++) {
					var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
				}
			}return function (Constructor, protoProps, staticProps) {
				if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
			};
		}();

		var _metalEvents = require("frontend-js-metal-web$metal-events");

		function _classCallCheck(instance, Constructor) {
			if (!(instance instanceof Constructor)) {
				throw new TypeError("Cannot call a class as a function");
			}
		}

		function _possibleConstructorReturn(self, call) {
			if (!self) {
				throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
			}return call && (typeof call === "object" || typeof call === "function") ? call : self;
		}

		function _inherits(subClass, superClass) {
			if (typeof superClass !== "function" && superClass !== null) {
				throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
			}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
		}

		/**
   * This is a special EventHandle, that is responsible for dom events, instead
   * of EventEmitter events.
   * @extends {EventHandle}
   */
		var DomEventHandle = function (_EventHandle) {
			_inherits(DomEventHandle, _EventHandle);

			/**
    * The constructor for `DomEventHandle`.
    * @param {!EventEmitter} emitter Emitter the event was subscribed to.
    * @param {string} event The name of the event that was subscribed to.
    * @param {!Function} listener The listener subscribed to the event.
    * @param {boolean} capture Flag indicating if listener should be triggered
    *   during capture phase, instead of during the bubbling phase. Defaults to false.
    * @constructor
    */
			function DomEventHandle(emitter, event, listener, capture) {
				_classCallCheck(this, DomEventHandle);

				var _this = _possibleConstructorReturn(this, (DomEventHandle.__proto__ || Object.getPrototypeOf(DomEventHandle)).call(this, emitter, event, listener));

				_this.capture_ = capture;
				return _this;
			}

			/**
    * @inheritDoc
    */

			_createClass(DomEventHandle, [{
				key: 'removeListener',
				value: function removeListener() {
					this.emitter_.removeEventListener(this.event_, this.listener_, this.capture_);
				}
			}]);

			return DomEventHandle;
		}(_metalEvents.EventHandle);

		exports.default = DomEventHandle;
		//# sourceMappingURL=DomEventHandle.js.map
	}
});
//# sourceMappingURL=DomEventHandle.js.map
'use strict';

Liferay.Loader.define('frontend-js-metal-web$metal-dom@2.16.8/lib/domNamed', ['module', 'exports', 'require', 'frontend-js-metal-web$metal', './domData', './DomDelegatedEventHandle', './DomEventHandle'], function (module, exports, require) {
	var define = undefined;
	var global = window;
	{
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.customEvents = undefined;
		exports.addClasses = addClasses;
		exports.closest = closest;
		exports.append = append;
		exports.buildFragment = buildFragment;
		exports.contains = contains;
		exports.delegate = delegate;
		exports.isNodeListLike = isNodeListLike;
		exports.enterDocument = enterDocument;
		exports.exitDocument = exitDocument;
		exports.hasClass = hasClass;
		exports.isEmpty = isEmpty;
		exports.match = match;
		exports.next = next;
		exports.on = on;
		exports.once = once;
		exports.parent = parent;
		exports.prepend = prepend;
		exports.registerCustomEvent = registerCustomEvent;
		exports.removeChildren = removeChildren;
		exports.removeClasses = removeClasses;
		exports.replace = replace;
		exports.supportsEvent = supportsEvent;
		exports.toElement = toElement;
		exports.toggleClasses = toggleClasses;
		exports.triggerEvent = triggerEvent;

		var _metal = require('frontend-js-metal-web$metal');

		var _domData = require('./domData');

		var _domData2 = _interopRequireDefault(_domData);

		var _DomDelegatedEventHandle = require('./DomDelegatedEventHandle');

		var _DomDelegatedEventHandle2 = _interopRequireDefault(_DomDelegatedEventHandle);

		var _DomEventHandle = require('./DomEventHandle');

		var _DomEventHandle2 = _interopRequireDefault(_DomEventHandle);

		function _interopRequireDefault(obj) {
			return obj && obj.__esModule ? obj : { default: obj };
		}

		var elementsByTag_ = {};
		var supportCache_ = {};
		var customEvents = exports.customEvents = {};

		var LAST_CONTAINER = '__metal_last_container__';
		var USE_CAPTURE = {
			blur: true,
			error: true,
			focus: true,
			invalid: true,
			load: true,
			scroll: true
		};

		/**
   * Adds the requested CSS classes to an element.
   * @param {!Element|!Nodelist} elements The element or elements to add CSS classes to.
   * @param {string} classes CSS classes to add.
   */
		function addClasses(elements, classes) {
			if (!(0, _metal.isObject)(elements) || !(0, _metal.isString)(classes)) {
				return;
			}

			if (!elements.length) {
				elements = [elements];
			}

			for (var i = 0; i < elements.length; i++) {
				if ('classList' in elements[i]) {
					addClassesWithNative_(elements[i], classes);
				} else {
					addClassesWithoutNative_(elements[i], classes);
				}
			}
		}

		/**
   * Adds the requested CSS classes to an element using classList.
   * @param {!Element} element The element to add CSS classes to.
   * @param {string} classes CSS classes to add.
   * @private
   */
		function addClassesWithNative_(element, classes) {
			classes.split(' ').forEach(function (className) {
				if (className) {
					element.classList.add(className);
				}
			});
		}

		/**
   * IE11 doesn't support Element.classList.add function, this method
   * adds the requested CSS classes to an element without using classList.
   * @param {!Element} element The element to add CSS classes to.
   * @param {string} classes CSS classes to add.
   * @private
   */
		function addClassesWithoutNative_(element, classes) {
			var elementClassName = ' ' + element.className + ' ';
			var classesToAppend = '';

			classes = classes.split(' ');

			for (var i = 0; i < classes.length; i++) {
				var className = classes[i];

				if (elementClassName.indexOf(' ' + className + ' ') === -1) {
					classesToAppend += ' ' + className;
				}
			}

			if (classesToAppend) {
				element.className = element.className + classesToAppend;
			}
		}

		/**
   * Adds an event listener to the given element, to be triggered via delegate.
   * @param {!Element} element
   * @param {string} eventName
   * @param {!function()} listener
   * @private
   */
		function addElementListener_(element, eventName, listener) {
			addToArr_(_domData2.default.get(element, 'listeners', {}), eventName, listener);
		}

		/**
   * Adds an event listener to the given element, to be triggered via delegate
   * selectors.
   * @param {!Element} element
   * @param {string} eventName
   * @param {string} selector
   * @param {!function()} listener
   * @private
   */
		function addSelectorListener_(element, eventName, selector, listener) {
			var delegatingData = _domData2.default.get(element, 'delegating', {});
			addToArr_(delegatingData[eventName].selectors, selector, listener);
		}

		/**
   * Adds a value to an array inside an object, creating it first if it doesn't
   * yet exist.
   * @param {!Array} arr
   * @param {string} key
   * @param {*} value
   * @private
   */
		function addToArr_(arr, key, value) {
			if (!arr[key]) {
				arr[key] = [];
			}
			arr[key].push(value);
		}

		/**
   * Attaches a delegate listener, unless there's already one attached.
   * @param {!Element} element
   * @param {string} eventName
   * @private
   */
		function attachDelegateEvent_(element, eventName) {
			var delegatingData = _domData2.default.get(element, 'delegating', {});
			if (!delegatingData[eventName]) {
				delegatingData[eventName] = {
					handle: on(element, eventName, handleDelegateEvent_, !!USE_CAPTURE[eventName]),
					selectors: {}
				};
			}
		}

		/**
   * IE11 doesn't support Element.closest function, this method
   * gets the closest element up the tree from the given element (including
   * itself) that matches the specified selector, or null if none match.
   * @param {Element} element
   * @param {string} selector
   * @return {Element}
   */
		function closest(element, selector) {
			while (element && !match(element, selector)) {
				element = element.parentNode;
			}
			return element;
		}

		/**
   * IE11 doesn't support Element.classList.add function, this method
   * appends a child node with text or other nodes to a parent node. If
   * child is a HTML string it will be automatically converted to a document
   * fragment before appending it to the parent.
   * @param {!Element} parent The node to append nodes to.
   * @param {!(Element|NodeList|string)} child The thing to append to the parent.
   * @return {!Element} The appended child.
   */
		function append(parent, child) {
			if ((0, _metal.isString)(child)) {
				child = buildFragment(child);
			}
			if (isNodeListLike(child)) {
				var childArr = Array.prototype.slice.call(child);
				for (var i = 0; i < childArr.length; i++) {
					parent.appendChild(childArr[i]);
				}
			} else {
				parent.appendChild(child);
			}
			return child;
		}

		/**
   * Helper for converting a HTML string into a document fragment.
   * @param {string} htmlString The HTML string to convert.
   * @return {!Element} The resulting document fragment.
   */
		function buildFragment(htmlString) {
			var tempDiv = document.createElement('div');
			tempDiv.innerHTML = '<br>' + htmlString;
			tempDiv.removeChild(tempDiv.firstChild);

			var fragment = document.createDocumentFragment();
			while (tempDiv.firstChild) {
				fragment.appendChild(tempDiv.firstChild);
			}
			return fragment;
		}

		/**
   * Checks if the first element contains the second one.
   * @deprecated Use element1.contains(element2) directly instead of this method
   * @param {!Element} element1
   * @param {!Element} element2
   * @return {boolean}
   */
		function contains(element1, element2) {
			if ((0, _metal.isDocument)(element1)) {
				// document.contains is not defined on IE9, so call it on documentElement instead.
				return element1.documentElement.contains(element2);
			} else {
				return element1.contains(element2);
			}
		}

		/**
   * Listens to the specified event on the given DOM element, but only calls the
   * given callback listener when it's triggered by elements that match the
   * given selector or target element.
   * @param {!Element} element The DOM element the event should be listened on.
   * @param {string} eventName The name of the event to listen to.
   * @param {!Element|string} selectorOrTarget Either an element or css selector
   *     that should match the event for the listener to be triggered.
   * @param {!function(!Object)} callback Function to be called when the event
   *     is triggered. It will receive the normalized event object.
   * @param {boolean=} defaultListener Optional flag indicating if this is a default
   *     listener. That means that it would only be executed after all non
   *     default listeners, and only if the event isn't prevented via
   *     `preventDefault`.
   * @return {!EventHandle} Can be used to remove the listener.
   */
		function delegate(element, eventName, selectorOrTarget, callback, defaultListener) {
			var customConfig = customEvents[eventName];
			if (customConfig && customConfig.delegate) {
				eventName = customConfig.originalEvent;
				callback = customConfig.handler.bind(customConfig, callback);
			}

			if (defaultListener) {
				// Wrap callback so we don't set property directly on it.
				callback = callback.bind();
				callback.defaultListener_ = true;
			}

			attachDelegateEvent_(element, eventName);
			if ((0, _metal.isString)(selectorOrTarget)) {
				addSelectorListener_(element, eventName, selectorOrTarget, callback);
			} else {
				addElementListener_(selectorOrTarget, eventName, callback);
			}

			return new _DomDelegatedEventHandle2.default((0, _metal.isString)(selectorOrTarget) ? element : selectorOrTarget, eventName, callback, (0, _metal.isString)(selectorOrTarget) ? selectorOrTarget : null);
		}

		/**
   * Verifies if the element is able to trigger the Click event,
   * simulating browsers behaviour, avoiding event listeners to be called by triggerEvent method.
   * @param {Element} node Element to be checked.
   * @param {string} eventName The event name.
   * @param {Object=} eventObj
   * @private
   * @return {boolean}
   */
		function isAbleToInteractWith_(node, eventName, eventObj) {
			if (eventObj && eventName === 'click' && eventObj.button === 2) {
				// Firefox triggers "click" events on the document for right clicks. This
				// causes our delegate logic to trigger it for regular elements too, which
				// shouldn't happen. Ignoring them here.
				return false;
			}

			if (eventName === 'click' && ['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'FIELDSET'].indexOf(node.tagName) > -1) {
				return !(node.disabled || parent(node, 'fieldset[disabled]'));
			}
			return true;
		}

		/**
   * Returns true if the specified value is a NodeList or like one.
   * @param {?} val Variable to test.
   * @return {boolean} Whether variable is like a NodeList.
   */
		function isNodeListLike(val) {
			return (0, _metal.isDefAndNotNull)(val) && typeof val.length === 'number' && typeof val.item === 'function';
		}

		/**
   * Inserts node in document as last element.
   * @param {Element} node Element to remove children from.
   */
		function enterDocument(node) {
			node && append(document.body, node);
		}

		/**
   * Removes node from document.
   * @param {Element} node Element to remove children from.
   */
		function exitDocument(node) {
			if (node && node.parentNode) {
				node.parentNode.removeChild(node);
			}
		}

		/**
   * This is called when an event is triggered by a delegate listener. All
   * matching listeners of this event type from `target` to `currentTarget` will
   * be triggered.
   * @param {!Event} event The event payload.
   * @return {boolean} False if at least one of the triggered callbacks returns
   *     false, or true otherwise.
   * @private
   */
		function handleDelegateEvent_(event) {
			normalizeDelegateEvent_(event);
			var ret = true;
			var container = event.currentTarget;
			var defFns = [];

			ret &= triggerDelegatedListeners_(container, event, defFns);
			ret &= triggerDefaultDelegatedListeners_(defFns, event);

			event.delegateTarget = null;
			event[LAST_CONTAINER] = container;
			return ret;
		}

		/**
   * Checks if the given element has the requested css class.
   * @param {!Element} element
   * @param {string} className
   * @return {boolean}
   */
		function hasClass(element, className) {
			if ('classList' in element) {
				return hasClassWithNative_(element, className);
			} else {
				return hasClassWithoutNative_(element, className);
			}
		}

		/**
   * Checks if the given element has the requested css class using classList.
   * @param {!Element} element
   * @param {string} className
   * @return {boolean}
   * @private
   */
		function hasClassWithNative_(element, className) {
			return className.indexOf(' ') === -1 && element.classList.contains(className);
		}

		/**
   * Checks if the given element has the requested css class without using classList.
   * @param {!Element} element
   * @param {string} className
   * @return {boolean}
   * @private
   */
		function hasClassWithoutNative_(element, className) {
			return (' ' + element.className + ' ').indexOf(' ' + className + ' ') >= 0 && className.split(' ').length === 1;
		}

		/**
   * Checks if the given element is empty or not.
   * @param {!Element} element
   * @return {boolean}
   */
		function isEmpty(element) {
			return element.childNodes.length === 0;
		}

		/**
   * IE11 doesn't support Element.matches function, this method
   * check if an element matches a given selector.
   * @param {Element} element
   * @param {string} selector
   * @return {boolean}
   */
		function match(element, selector) {
			if (!element || element.nodeType !== 1) {
				return false;
			}

			var p = Element.prototype;
			var m = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector;
			if (m) {
				return m.call(element, selector);
			}

			return matchFallback_(element, selector);
		}

		/**
   * Check if an element matches a given selector, using an internal implementation
   * instead of calling existing javascript functions.
   * @param {Element} element
   * @param {string} selector
   * @return {boolean}
   * @private
   */
		function matchFallback_(element, selector) {
			var parentNode = element.parentNode;

			if (parentNode) {
				var nodes = parentNode.querySelectorAll(selector);

				for (var i = 0; i < nodes.length; ++i) {
					if (nodes[i] === element) {
						return true;
					}
				}
			}

			return false;
		}

		/**
   * Returns the next sibling of the given element that matches the specified
   * selector, or null if there is none.
   * @param {!Element} element
   * @param {?string} selector
   * @return {Element|null}
   */
		function next(element, selector) {
			do {
				element = element.nextSibling;
				if (element && match(element, selector)) {
					return element;
				}
			} while (element);
			return null;
		}

		/**
   * Normalizes the event payload for delegate listeners.
   * @param {!Event} event
   * @private
   */
		function normalizeDelegateEvent_(event) {
			event.stopPropagation = stopPropagation_;
			event.stopImmediatePropagation = stopImmediatePropagation_;
		}

		/**
   * Listens to the specified event on the given DOM element. This function normalizes
   * DOM event payloads and functions so they'll work the same way on all supported
   * browsers.
   * @param {!Element|string} element The DOM element to listen to the event on, or
   *   a selector that should be delegated on the entire document.
   * @param {string} eventName The name of the event to listen to.
   * @param {!function(!Object)} callback Function to be called when the event is
   *   triggered. It will receive the normalized event object.
   * @param {boolean} capture Flag indicating if listener should be triggered
   *   during capture phase, instead of during the bubbling phase. Defaults to false.
   * @return {!DomEventHandle} Can be used to remove the listener.
   */
		function on(element, eventName, callback, capture) {
			if ((0, _metal.isString)(element)) {
				return delegate(document, eventName, element, callback);
			}
			var customConfig = customEvents[eventName];
			if (customConfig && customConfig.event) {
				eventName = customConfig.originalEvent;
				callback = customConfig.handler.bind(customConfig, callback);
			}
			element.addEventListener(eventName, callback, capture);
			return new _DomEventHandle2.default(element, eventName, callback, capture);
		}

		/**
   * IE11 doesn't support once event listener option, this method
   * Listens to the specified event on the given DOM element once. This
   * function normalizes DOM event payloads and functions so they'll work the
   * same way on all supported browsers.
   * @param {!Element} element The DOM element to listen to the event on.
   * @param {string} eventName The name of the event to listen to.
   * @param {!function(!Object)} callback Function to be called when the event
   *   is triggered. It will receive the normalized event object.
   * @return {!DomEventHandle} Can be used to remove the listener.
   */
		function once(element, eventName, callback) {
			var domEventHandle = on(element, eventName, function () {
				domEventHandle.removeListener();
				return callback.apply(this, arguments); // eslint-disable-line
			});
			return domEventHandle;
		}

		/**
   * Gets the first parent from the given element that matches the specified
   * selector, or null if none match.
   * @param {!Element} element
   * @param {string} selector
   * @return {Element}
   */
		function parent(element, selector) {
			return closest(element.parentNode, selector);
		}

		/**
   * IE11 doesn't support Element.prepend function, this method
   * inserts a node before first child of the parent. If child is a HTML string
   * it will be converted to document fragment before prepending it to the parent.
   * @param {!Element} parent The node to prepend to.
   * @param {!(Element|NodeList|string)} child The thing to prepend to the parent.
   * @return {!Element} The prepended child.
   */
		function prepend(parent, child) {
			if ((0, _metal.isString)(child)) {
				child = buildFragment(child);
			}

			if (!isNodeListLike(child) && !(0, _metal.isDefAndNotNull)(parent.firstChild)) {
				return append(parent, child);
			}

			if (isNodeListLike(child)) {
				var childArr = Array.prototype.slice.call(child);
				for (var i = childArr.length - 1; i >= 0; i--) {
					parent.insertBefore(childArr[i], parent.firstChild);
				}
			} else {
				parent.insertBefore(child, parent.firstChild);
			}

			return child;
		}

		/**
   * Registers a custom event.
   * @param {string} eventName The name of the custom event.
   * @param {!Object} customConfig An object with information about how the event
   *   should be handled.
   */
		function registerCustomEvent(eventName, customConfig) {
			customEvents[eventName] = customConfig;
		}

		/**
   * Removes all the child nodes on a DOM node.
   * @param {Element} node Element to remove children from.
   */
		function removeChildren(node) {
			var child = void 0;
			while (child = node.firstChild) {
				node.removeChild(child);
			}
		}

		/**
   * Removes the requested CSS classes from an element.
   * @param {!Element|!NodeList} elements The element or elements to remove CSS classes from.
   * @param {string} classes CSS classes to remove.
   */
		function removeClasses(elements, classes) {
			if (!(0, _metal.isObject)(elements) || !(0, _metal.isString)(classes)) {
				return;
			}

			if (!elements.length) {
				elements = [elements];
			}

			for (var i = 0; i < elements.length; i++) {
				if ('classList' in elements[i]) {
					removeClassesWithNative_(elements[i], classes);
				} else {
					removeClassesWithoutNative_(elements[i], classes);
				}
			}
		}

		/**
   * Removes the requested CSS classes from an element using classList.
   * @param {!Element} element The element to remove CSS classes from.
   * @param {string} classes CSS classes to remove.
   * @private
   */
		function removeClassesWithNative_(element, classes) {
			classes.split(' ').forEach(function (className) {
				if (className) {
					element.classList.remove(className);
				}
			});
		}

		/**
   * IE11 doesn't support Element.classList, this method
   * removes the requested CSS classes from an element without using classList.
   * @param {!Element} element The element to remove CSS classes from.
   * @param {string} classes CSS classes to remove.
   * @private
   */
		function removeClassesWithoutNative_(element, classes) {
			var elementClassName = ' ' + element.className + ' ';

			classes = classes.split(' ');

			for (var i = 0; i < classes.length; i++) {
				elementClassName = elementClassName.replace(' ' + classes[i] + ' ', ' ');
			}

			element.className = elementClassName.trim();
		}

		/**
   * Replaces the first element with the second.
   * @deprecated Use element1.parentNode.replaceChild(element2, element1)
   * directly instead of this method
   * @param {Element} element1
   * @param {Element} element2
   */
		function replace(element1, element2) {
			if (element1 && element2 && element1 !== element2 && element1.parentNode) {
				element1.parentNode.replaceChild(element2, element1);
			}
		}

		/**
   * The function that replaces `stopImmediatePropagation_` for events.
   * @private
   */
		function stopImmediatePropagation_() {
			var event = this; // eslint-disable-line
			event.stopped = true;
			event.stoppedImmediate = true;
			Event.prototype.stopImmediatePropagation.call(event);
		}

		/**
   * The function that replaces `stopPropagation` for events.
   * @private
   */
		function stopPropagation_() {
			var event = this; // eslint-disable-line
			event.stopped = true;
			Event.prototype.stopPropagation.call(event);
		}

		/**
   * Checks if the given element supports the given event type.
   * @param {!Element|string} element The DOM element or element tag name to check.
   * @param {string} eventName The name of the event to check.
   * @return {boolean}
   */
		function supportsEvent(element, eventName) {
			if (customEvents[eventName]) {
				return true;
			}

			if ((0, _metal.isString)(element)) {
				if (!elementsByTag_[element]) {
					elementsByTag_[element] = document.createElement(element);
				}
				element = elementsByTag_[element];
			}

			var tag = element.tagName;
			if (!supportCache_[tag] || !supportCache_[tag].hasOwnProperty(eventName)) {
				supportCache_[tag] = supportCache_[tag] || {};
				supportCache_[tag][eventName] = 'on' + eventName in element;
			}
			return supportCache_[tag][eventName];
		}

		/**
   * This triggers all default matched delegated listeners of a given event type.
   * @param {!Array} defFns Array to collect default listeners in, instead
   * @param {!Event} event
   * @return {boolean} False if at least one of the triggered callbacks returns
   *     false, or true otherwise.
   * @private
   */
		function triggerDefaultDelegatedListeners_(defFns, event) {
			var ret = true;

			for (var i = 0; i < defFns.length && !event.defaultPrevented; i++) {
				event.delegateTarget = defFns[i].element;
				ret &= defFns[i].fn(event);
			}

			return ret;
		}

		/**
   * This triggers all matched delegated listeners of a given event type when its
   * delegated target is able to interact.
   * @param {!Element} container
   * @param {!Event} event
   * @param {!Array} defaultFns Array to collect default listeners in, instead
   *     of running them.
   * @return {boolean} False if at least one of the triggered callbacks returns
   *     false, or true otherwise.
   * @private
   */
		function triggerDelegatedListeners_(container, event, defaultFns) {
			var ret = true;
			var currElement = event.target;
			var limit = container.parentNode;

			while (currElement && currElement !== limit && !event.stopped) {
				if (isAbleToInteractWith_(currElement, event.type, event)) {
					event.delegateTarget = currElement;
					ret &= triggerElementListeners_(currElement, event, defaultFns);
					ret &= triggerSelectorListeners_(container, currElement, event, defaultFns);
				}
				currElement = currElement.parentNode;
			}

			return ret;
		}

		/**
   * Converts the given argument to a DOM element. Strings are assumed to
   * be selectors, and so a matched element will be returned. If the arg
   * is already a DOM element it will be the return value.
   * @param {string|Element|Document} selectorOrElement
   * @return {Element} The converted element, or null if none was found.
   */
		function toElement(selectorOrElement) {
			if ((0, _metal.isElement)(selectorOrElement) || (0, _metal.isDocument)(selectorOrElement) || (0, _metal.isDocumentFragment)(selectorOrElement)) {
				return selectorOrElement;
			} else if ((0, _metal.isString)(selectorOrElement)) {
				return document.querySelector(selectorOrElement);
			} else {
				return null;
			}
		}

		/**
   * Adds or removes one or more classes from an element. If any of the classes
   * is present, it will be removed from the element, or added otherwise.
   * @param {!Element} element The element which classes will be toggled.
   * @param {string} classes The classes which have to added or removed from the element.
   */
		function toggleClasses(element, classes) {
			if (!(0, _metal.isObject)(element) || !(0, _metal.isString)(classes)) {
				return;
			}

			if ('classList' in element) {
				toggleClassesWithNative_(element, classes);
			} else {
				toggleClassesWithoutNative_(element, classes);
			}
		}

		/**
   * Adds or removes one or more classes from an element using classList.
   * If any of the classes is present, it will be removed from the element,
   * or added otherwise.
   * @param {!Element} element The element which classes will be toggled.
   * @param {string} classes The classes which have to added or removed from the element.
   * @private
   */
		function toggleClassesWithNative_(element, classes) {
			classes.split(' ').forEach(function (className) {
				element.classList.toggle(className);
			});
		}

		/**
   * IE11 doesn't support Element.classList, this method
   * adds or removes one or more classes from an element without using classList.
   * If any of the classes is present, it will be removed from the element,
   * or added otherwise.
   * @param {!Element} element The element which classes will be toggled.
   * @param {string} classes The classes which have to added or removed from the element.
   * @private
   */
		function toggleClassesWithoutNative_(element, classes) {
			var elementClassName = ' ' + element.className + ' ';

			classes = classes.split(' ');

			for (var i = 0; i < classes.length; i++) {
				var className = ' ' + classes[i] + ' ';
				var classIndex = elementClassName.indexOf(className);

				if (classIndex === -1) {
					elementClassName = '' + elementClassName + classes[i] + ' ';
				} else {
					var before = elementClassName.substring(0, classIndex);
					var after = elementClassName.substring(classIndex + className.length); // eslint-disable-line
					elementClassName = before + ' ' + after;
				}
			}

			element.className = elementClassName.trim();
		}

		/**
   * Triggers all listeners for the given event type that are stored in the
   * specified element.
   * @param {!Element} element
   * @param {!Event} event
   * @param {!Array} defaultFns Array to collect default listeners in, instead
   *     of running them.
   * @return {boolean} False if at least one of the triggered callbacks returns
   *     false, or true otherwise.
   * @private
   */
		function triggerElementListeners_(element, event, defaultFns) {
			var lastContainer = event[LAST_CONTAINER];
			if (!(0, _metal.isDef)(lastContainer) || !contains(lastContainer, element)) {
				var listeners = _domData2.default.get(element, 'listeners', {})[event.type];
				return triggerListeners_(listeners, event, element, defaultFns);
			}
			return true;
		}

		/**
   * Triggers the specified event on the given element.
   * NOTE: This should mostly be used for testing, not on real code.
   * @param {!Element} element The node that should trigger the event.
   * @param {string} eventName The name of the event to be triggred.
   * @param {Object=} eventObj An object with data that should be on the
   *   triggered event's payload.
   */
		function triggerEvent(element, eventName, eventObj) {
			if (isAbleToInteractWith_(element, eventName, eventObj)) {
				var payload = document.createEvent('HTMLEvents');
				payload.initEvent(eventName, true, true);
				_metal.object.mixin(payload, eventObj);
				element.dispatchEvent(payload);
			}
		}

		/**
   * Triggers the given listeners array.
   * @param {Array<!function()>} listeners
   * @param {!Event} event
   * @param {!Element} element
   * @param {!Array} defaultFns Array to collect default listeners in, instead
   *     of running them.
   * @return {boolean} False if at least one of the triggered callbacks returns
   *     false, or true otherwise.
   * @private
   */
		function triggerListeners_(listeners, event, element, defaultFns) {
			var ret = true;
			listeners = listeners || [];
			for (var i = 0; i < listeners.length && !event.stoppedImmediate; i++) {
				if (listeners[i].defaultListener_) {
					defaultFns.push({
						element: element,
						fn: listeners[i]
					});
				} else {
					ret &= listeners[i](event);
				}
			}
			return ret;
		}

		/**
   * Triggers all selector listeners for the given event.
   * @param {!Element} container
   * @param {!Element} element
   * @param {!Event} event
   * @param {!Array} defaultFns Array to collect default listeners in, instead
   *     of running them.
   * @return {boolean} False if at least one of the triggered callbacks returns
   *     false, or true otherwise.
   * @private
   */
		function triggerSelectorListeners_(container, element, event, defaultFns) {
			var ret = true;
			var data = _domData2.default.get(container, 'delegating', {});
			var map = data[event.type].selectors;
			var selectors = Object.keys(map);
			for (var i = 0; i < selectors.length && !event.stoppedImmediate; i++) {
				if (match(element, selectors[i])) {
					var listeners = map[selectors[i]];
					ret &= triggerListeners_(listeners, event, element, defaultFns);
				}
			}
			return ret;
		}
		//# sourceMappingURL=domNamed.js.map
	}
});
//# sourceMappingURL=domNamed.js.map
'use strict';

// This file exists just for backwards compatibility, making sure that old
// default imports for this file still work. It's best to use the named exports
// for each function instead though, since that allows bundlers like Rollup to
// reduce the bundle size by removing unused code.

Liferay.Loader.define('frontend-js-metal-web$metal-dom@2.16.8/lib/dom', ['module', 'exports', 'require', './domNamed'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.dom = undefined;

    var _domNamed = require('./domNamed');

    Object.keys(_domNamed).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _domNamed[key];
        }
      });
    });

    var dom = _interopRequireWildcard(_domNamed);

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
          }
        }newObj.default = obj;return newObj;
      }
    }

    exports.default = dom;
    exports.dom = dom;
    //# sourceMappingURL=dom.js.map
  }
});
//# sourceMappingURL=dom.js.map
'use strict';

Liferay.Loader.define("frontend-js-metal-web$metal-dom@2.16.8/lib/DomEventEmitterProxy", ['module', 'exports', 'require', './dom', 'frontend-js-metal-web$metal-events'], function (module, exports, require) {
	var define = undefined;
	var global = window;
	{
		Object.defineProperty(exports, "__esModule", {
			value: true
		});

		var _createClass = function () {
			function defineProperties(target, props) {
				for (var i = 0; i < props.length; i++) {
					var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
				}
			}return function (Constructor, protoProps, staticProps) {
				if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
			};
		}();

		var _get = function get(object, property, receiver) {
			if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
				var parent = Object.getPrototypeOf(object);if (parent === null) {
					return undefined;
				} else {
					return get(parent, property, receiver);
				}
			} else if ("value" in desc) {
				return desc.value;
			} else {
				var getter = desc.get;if (getter === undefined) {
					return undefined;
				}return getter.call(receiver);
			}
		};

		var _dom = require('./dom');

		var _metalEvents = require("frontend-js-metal-web$metal-events");

		function _classCallCheck(instance, Constructor) {
			if (!(instance instanceof Constructor)) {
				throw new TypeError("Cannot call a class as a function");
			}
		}

		function _possibleConstructorReturn(self, call) {
			if (!self) {
				throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
			}return call && (typeof call === "object" || typeof call === "function") ? call : self;
		}

		function _inherits(subClass, superClass) {
			if (typeof superClass !== "function" && superClass !== null) {
				throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
			}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
		}

		/**
   * DomEventEmitterProxy utility. It extends `EventEmitterProxy` to also accept
   * dom elements as origin emitters.
   * @extends {EventEmitterProxy}
   */
		var DomEventEmitterProxy = function (_EventEmitterProxy) {
			_inherits(DomEventEmitterProxy, _EventEmitterProxy);

			function DomEventEmitterProxy() {
				_classCallCheck(this, DomEventEmitterProxy);

				return _possibleConstructorReturn(this, (DomEventEmitterProxy.__proto__ || Object.getPrototypeOf(DomEventEmitterProxy)).apply(this, arguments));
			}

			_createClass(DomEventEmitterProxy, [{
				key: 'addListener_',

				/**
     * Adds the given listener for the given event.
     * @param {string} event
     * @param {!function()} listener
     * @return {!EventHandle} The listened event's handle.
     * @protected
     * @override
     */
				value: function addListener_(event, listener) {
					if (this.originEmitter_.addEventListener) {
						if (this.isDelegateEvent_(event)) {
							var index = event.indexOf(':', 9);
							var eventName = event.substring(9, index);
							var selector = event.substring(index + 1);
							return (0, _dom.delegate)(this.originEmitter_, eventName, selector, listener); // eslint-disable-line
						} else {
							return (0, _dom.on)(this.originEmitter_, event, listener);
						}
					} else {
						return _get(DomEventEmitterProxy.prototype.__proto__ || Object.getPrototypeOf(DomEventEmitterProxy.prototype), 'addListener_', this).call(this, event, listener);
					}
				}

				/**
     * Checks if the given event is of the delegate type.
     * @param {string} event
     * @return {boolean}
     * @protected
     */

			}, {
				key: 'isDelegateEvent_',
				value: function isDelegateEvent_(event) {
					return event.substr(0, 9) === 'delegate:';
				}

				/**
     * Checks if the given event is supported by the origin element.
     * @param {string} event
     * @protected
     * @return {boolean}
     */

			}, {
				key: 'isSupportedDomEvent_',
				value: function isSupportedDomEvent_(event) {
					if (!this.originEmitter_ || !this.originEmitter_.addEventListener) {
						return true;
					}
					return this.isDelegateEvent_(event) && event.indexOf(':', 9) !== -1 || (0, _dom.supportsEvent)(this.originEmitter_, event);
				}

				/**
     * Checks if the given event should be proxied.
     * @param {string} event
     * @return {boolean}
     * @protected
     * @override
     */

			}, {
				key: 'shouldProxyEvent_',
				value: function shouldProxyEvent_(event) {
					return _get(DomEventEmitterProxy.prototype.__proto__ || Object.getPrototypeOf(DomEventEmitterProxy.prototype), 'shouldProxyEvent_', this).call(this, event) && this.isSupportedDomEvent_(event); // eslint-disable-line
				}
			}]);

			return DomEventEmitterProxy;
		}(_metalEvents.EventEmitterProxy);

		exports.default = DomEventEmitterProxy;
		//# sourceMappingURL=DomEventEmitterProxy.js.map
	}
});
//# sourceMappingURL=DomEventEmitterProxy.js.map
'use strict';

Liferay.Loader.define("frontend-js-metal-web$metal-dom@2.16.8/lib/features", ['module', 'exports', 'require', './dom', 'frontend-js-metal-web$metal'], function (module, exports, require) {
	var define = undefined;
	var global = window;
	{
		Object.defineProperty(exports, "__esModule", {
			value: true
		});

		var _createClass = function () {
			function defineProperties(target, props) {
				for (var i = 0; i < props.length; i++) {
					var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
				}
			}return function (Constructor, protoProps, staticProps) {
				if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
			};
		}();

		var _dom = require('./dom');

		var _metal = require("frontend-js-metal-web$metal");

		function _classCallCheck(instance, Constructor) {
			if (!(instance instanceof Constructor)) {
				throw new TypeError("Cannot call a class as a function");
			}
		}

		/**
   * Class with static methods responsible for doing browser feature checks.
   */
		var features = function () {
			function features() {
				_classCallCheck(this, features);
			}

			_createClass(features, null, [{
				key: 'checkAnimationEventName',

				/**
     * Some browsers still supports prefixed animation events. This method can
     * be used to retrieve the current browser event name for both, animation
     * and transition.
     * @return {object}
     */
				value: function checkAnimationEventName() {
					if (features.animationEventName_ === undefined) {
						features.animationEventName_ = {
							animation: features.checkAnimationEventName_('animation'),
							transition: features.checkAnimationEventName_('transition')
						};
					}
					return features.animationEventName_;
				}

				/**
     * @protected
     * @param {string} type Type to test: animation, transition.
     * @return {string} Browser event name.
     */

			}, {
				key: 'checkAnimationEventName_',
				value: function checkAnimationEventName_(type) {
					var prefixes = ['Webkit', 'MS', 'O', ''];
					var typeTitleCase = _metal.string.replaceInterval(type, 0, 1, type.substring(0, 1).toUpperCase());
					var suffixes = [typeTitleCase + 'End', typeTitleCase + 'End', typeTitleCase + 'End', type + 'end'];
					if (!features.animationElement_) {
						features.animationElement_ = document.createElement('div');
					}
					for (var i = 0; i < prefixes.length; i++) {
						if (features.animationElement_.style[prefixes[i] + typeTitleCase] !== undefined // eslint-disable-line
						) {
								return prefixes[i].toLowerCase() + suffixes[i];
							}
					}
					return type + 'end';
				}

				/**
     * Some browsers (like IE11, Edge) change the order of element attributes, when html
     * is rendered. This method can be used to check if this behavior happens on
     * the current browser.
     * @return {boolean}
     */

			}, {
				key: 'checkAttrOrderChange',
				value: function checkAttrOrderChange() {
					if (features.attrOrderChange_ === undefined) {
						var originalContent = '<div data-component="" data-ref=""></div>';
						var element = document.createElement('div');
						(0, _dom.append)(element, originalContent);
						features.attrOrderChange_ = originalContent !== element.innerHTML;
					}
					return features.attrOrderChange_;
				}
			}]);

			return features;
		}();

		features.animationElement_ = undefined;
		features.animationEventName_ = undefined;
		features.attrOrderChange_ = undefined;

		exports.default = features;
		//# sourceMappingURL=features.js.map
	}
});
//# sourceMappingURL=features.js.map
'use strict';

Liferay.Loader.define("frontend-js-metal-web$metal-dom@2.16.8/lib/globalEval", ['module', 'exports', 'require', 'frontend-js-metal-web$metal', './dom'], function (module, exports, require) {
	var define = undefined;
	var global = window;
	{
		Object.defineProperty(exports, "__esModule", {
			value: true
		});

		var _createClass = function () {
			function defineProperties(target, props) {
				for (var i = 0; i < props.length; i++) {
					var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
				}
			}return function (Constructor, protoProps, staticProps) {
				if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
			};
		}();

		var _metal = require("frontend-js-metal-web$metal");

		var _dom = require('./dom');

		function _classCallCheck(instance, Constructor) {
			if (!(instance instanceof Constructor)) {
				throw new TypeError("Cannot call a class as a function");
			}
		}

		/**
   * Utility functions for running javascript code in the global scope.
   */
		var globalEval = function () {
			function globalEval() {
				_classCallCheck(this, globalEval);
			}

			_createClass(globalEval, null, [{
				key: 'run',

				/**
     * Evaluates the given string in the global scope.
     * @param {string} text
     * @param {function()=} appendFn Optional function to append the node
     *   into document.
     * @return {Element} script
     */
				value: function run(text, appendFn) {
					var script = document.createElement('script');
					script.text = text;
					if (appendFn) {
						appendFn(script);
					} else {
						document.head.appendChild(script);
					}
					(0, _dom.exitDocument)(script);
					return script;
				}

				/**
     * Evaluates the given javascript file in the global scope.
     * @param {string} src The file's path.
     * @param {function()=} defaultFn Optional function to be called
     *   when the script has been run.
     * @param {function()=} appendFn Optional function to append the node
     *   into document.
     * @return {Element} script
     */

			}, {
				key: 'runFile',
				value: function runFile(src, defaultFn, appendFn) {
					var script = document.createElement('script');
					script.src = src;

					var callback = function callback() {
						(0, _dom.exitDocument)(script);
						defaultFn && defaultFn();
					};
					(0, _dom.once)(script, 'load', callback);
					(0, _dom.once)(script, 'error', callback);

					if (appendFn) {
						appendFn(script);
					} else {
						document.head.appendChild(script);
					}

					return script;
				}

				/**
     * Evaluates the code referenced by the given script element.
     * @param {!Element} script
     * @param {function()=} defaultFn Optional function to be called
     *   when the script has been run.
     * @param {function()=} appendFn Optional function to append the node
     *   into document.
     * @return {Element} script
     */

			}, {
				key: 'runScript',
				value: function runScript(script, defaultFn, appendFn) {
					var callback = function callback() {
						defaultFn && defaultFn();
					};
					if (script.type && script.type !== 'text/javascript') {
						_metal.async.nextTick(callback);
						return;
					}
					(0, _dom.exitDocument)(script);
					if (script.src) {
						return globalEval.runFile(script.src, defaultFn, appendFn);
					} else {
						_metal.async.nextTick(callback);
						return globalEval.run(script.text, appendFn);
					}
				}

				/**
     * Evaluates any script tags present in the given element.
     * @param {!Element} element
     * @param {function()=} defaultFn Optional function to be called
     *   when the script has been run.
     * @param {function()=} appendFn Optional function to append the node
     *   into document.
     */

			}, {
				key: 'runScriptsInElement',
				value: function runScriptsInElement(element, defaultFn, appendFn) {
					var scripts = element.querySelectorAll('script');
					if (scripts.length) {
						globalEval.runScriptsInOrder(scripts, 0, defaultFn, appendFn);
					} else if (defaultFn) {
						_metal.async.nextTick(defaultFn);
					}
				}

				/**
     * Runs the given scripts elements in the order that they appear.
     * @param {!NodeList} scripts
     * @param {number} index
     * @param {function()=} defaultFn Optional function to be called
     *   when the script has been run.
     * @param {function()=} appendFn Optional function to append the node
     *   into document.
     */

			}, {
				key: 'runScriptsInOrder',
				value: function runScriptsInOrder(scripts, index, defaultFn, appendFn) {
					globalEval.runScript(scripts.item(index), function () {
						if (index < scripts.length - 1) {
							globalEval.runScriptsInOrder(scripts, index + 1, defaultFn, appendFn); // eslint-disable-line
						} else if (defaultFn) {
							_metal.async.nextTick(defaultFn);
						}
					}, appendFn);
				}
			}]);

			return globalEval;
		}();

		exports.default = globalEval;
		//# sourceMappingURL=globalEval.js.map
	}
});
//# sourceMappingURL=globalEval.js.map
'use strict';

Liferay.Loader.define("frontend-js-metal-web$metal-dom@2.16.8/lib/globalEvalStyles", ['module', 'exports', 'require', 'frontend-js-metal-web$metal', './dom'], function (module, exports, require) {
	var define = undefined;
	var global = window;
	{
		Object.defineProperty(exports, "__esModule", {
			value: true
		});

		var _createClass = function () {
			function defineProperties(target, props) {
				for (var i = 0; i < props.length; i++) {
					var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
				}
			}return function (Constructor, protoProps, staticProps) {
				if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
			};
		}();

		var _metal = require("frontend-js-metal-web$metal");

		var _dom = require('./dom');

		function _classCallCheck(instance, Constructor) {
			if (!(instance instanceof Constructor)) {
				throw new TypeError("Cannot call a class as a function");
			}
		}

		/**
   * Utility functions for running styles.
   */
		var globalEvalStyles = function () {
			function globalEvalStyles() {
				_classCallCheck(this, globalEvalStyles);
			}

			_createClass(globalEvalStyles, null, [{
				key: 'run',

				/**
     * Evaluates the given style.
     * @param {string} text
     * @param {function()=} appendFn Optional function to append the node
     *   into document.
     * @return {Element} style
     */
				value: function run(text, appendFn) {
					var style = document.createElement('style');
					style.innerHTML = text;
					if (appendFn) {
						appendFn(style);
					} else {
						document.head.appendChild(style);
					}
					return style;
				}

				/**
     * Evaluates the given style file.
     * @param {string} href The file's path.
     * @param {function()=} defaultFn Optional function to be called
     *   when the styles has been run.
     * @param {function()=} appendFn Optional function to append the node
     *   into document.
     * @return {Element} style
     */

			}, {
				key: 'runFile',
				value: function runFile(href, defaultFn, appendFn) {
					var link = document.createElement('link');
					link.rel = 'stylesheet';
					link.href = href;
					globalEvalStyles.runStyle(link, defaultFn, appendFn);
					return link;
				}

				/**
     * Evaluates the code referenced by the given style/link element.
     * @param {!Element} style
     * @param {function()=} defaultFn Optional function to be called
     *   when the script has been run.
     * @param {function()=} appendFn Optional function to append the node
     *   into document.
     *  @return {Element} style
     */

			}, {
				key: 'runStyle',
				value: function runStyle(style, defaultFn, appendFn) {
					var callback = function callback() {
						defaultFn && defaultFn();
					};
					if (style.rel && style.rel !== 'stylesheet' && style.rel !== 'canonical' && style.rel !== 'alternate') {
						_metal.async.nextTick(callback);
						return;
					}

					if (style.tagName === 'STYLE' || style.rel === 'canonical' || style.rel === 'alternate') {
						_metal.async.nextTick(callback);
					} else {
						(0, _dom.once)(style, 'load', callback);
						(0, _dom.once)(style, 'error', callback);
					}

					if (appendFn) {
						appendFn(style);
					} else {
						document.head.appendChild(style);
					}

					return style;
				}

				/**
     * Evaluates any style present in the given element.
     * @param {!Element} element
     * @param {function()=} defaultFn Optional function to be called when the
     *   style has been run.
     * @param {function()=} appendFn Optional function to append the node
     *   into document.
     */

			}, {
				key: 'runStylesInElement',
				value: function runStylesInElement(element, defaultFn, appendFn) {
					var styles = element.querySelectorAll('style,link');
					if (styles.length === 0 && defaultFn) {
						_metal.async.nextTick(defaultFn);
						return;
					}

					var loadCount = 0;
					var callback = function callback() {
						if (defaultFn && ++loadCount === styles.length) {
							_metal.async.nextTick(defaultFn);
						}
					};
					for (var i = 0; i < styles.length; i++) {
						globalEvalStyles.runStyle(styles[i], callback, appendFn);
					}
				}
			}]);

			return globalEvalStyles;
		}();

		exports.default = globalEvalStyles;
		//# sourceMappingURL=globalEvalStyles.js.map
	}
});
//# sourceMappingURL=globalEvalStyles.js.map
'use strict';

Liferay.Loader.define('frontend-js-metal-web$metal-dom@2.16.8/lib/events', ['module', 'exports', 'require', 'frontend-js-metal-web$metal', './dom', './features'], function (module, exports, require) {
	var define = undefined;
	var global = window;
	{
		var _metal = require('frontend-js-metal-web$metal');

		var _dom = require('./dom');

		var _features = require('./features');

		var _features2 = _interopRequireDefault(_features);

		function _interopRequireDefault(obj) {
			return obj && obj.__esModule ? obj : { default: obj };
		}

		/**
   * Register custom events for event delegation.
   */
		function registerEvents() {
			var mouseEventMap = {
				mouseenter: 'mouseover',
				mouseleave: 'mouseout',
				pointerenter: 'pointerover',
				pointerleave: 'pointerout'
			};
			Object.keys(mouseEventMap).forEach(function (eventName) {
				(0, _dom.registerCustomEvent)(eventName, {
					delegate: true,
					handler: function handler(callback, event) {
						var related = event.relatedTarget;
						var target = event.delegateTarget;
						// eslint-disable-next-line
						if (!related || related !== target && !(0, _dom.contains)(target, related)) {
							event.customType = eventName;
							return callback(event);
						}
					},
					originalEvent: mouseEventMap[eventName]
				});
			});

			var animationEventMap = {
				animation: 'animationend',
				transition: 'transitionend'
			};
			Object.keys(animationEventMap).forEach(function (eventType) {
				var eventName = animationEventMap[eventType];
				(0, _dom.registerCustomEvent)(eventName, {
					event: true,
					delegate: true,
					handler: function handler(callback, event) {
						event.customType = eventName;
						return callback(event);
					},
					originalEvent: _features2.default.checkAnimationEventName()[eventType]
				});
			});
		}

		if (!(0, _metal.isServerSide)()) {
			registerEvents();
		}
		//# sourceMappingURL=events.js.map
	}
});
//# sourceMappingURL=events.js.map
'use strict';

Liferay.Loader.define('frontend-js-metal-web$metal-dom@2.16.8/lib/all/dom', ['module', 'exports', 'require', '../dom', '../domData', '../DomEventEmitterProxy', '../DomEventHandle', '../features', '../globalEval', '../globalEvalStyles', '../events'], function (module, exports, require) {
	var define = undefined;
	var global = window;
	{
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.globalEvalStyles = exports.globalEval = exports.features = exports.DomEventHandle = exports.DomEventEmitterProxy = exports.domData = undefined;

		var _dom = require('../dom');

		Object.keys(_dom).forEach(function (key) {
			if (key === "default" || key === "__esModule") return;
			Object.defineProperty(exports, key, {
				enumerable: true,
				get: function get() {
					return _dom[key];
				}
			});
		});

		var _dom2 = _interopRequireDefault(_dom);

		var _domData = require('../domData');

		var _domData2 = _interopRequireDefault(_domData);

		var _DomEventEmitterProxy = require('../DomEventEmitterProxy');

		var _DomEventEmitterProxy2 = _interopRequireDefault(_DomEventEmitterProxy);

		var _DomEventHandle = require('../DomEventHandle');

		var _DomEventHandle2 = _interopRequireDefault(_DomEventHandle);

		var _features = require('../features');

		var _features2 = _interopRequireDefault(_features);

		var _globalEval = require('../globalEval');

		var _globalEval2 = _interopRequireDefault(_globalEval);

		var _globalEvalStyles = require('../globalEvalStyles');

		var _globalEvalStyles2 = _interopRequireDefault(_globalEvalStyles);

		require('../events');

		function _interopRequireDefault(obj) {
			return obj && obj.__esModule ? obj : { default: obj };
		}

		exports.domData = _domData2.default;
		exports.DomEventEmitterProxy = _DomEventEmitterProxy2.default;
		exports.DomEventHandle = _DomEventHandle2.default;
		exports.features = _features2.default;
		exports.globalEval = _globalEval2.default;
		exports.globalEvalStyles = _globalEvalStyles2.default;
		exports.default = _dom2.default;
		//# sourceMappingURL=dom.js.map
	}
});
//# sourceMappingURL=dom.js.map
